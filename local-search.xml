<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CS144-Lab4实验笔记</title>
    <link href="/202205/cs144-lab4/"/>
    <url>/202205/cs144-lab4/</url>
    
    <content type="html"><![CDATA[<h2 id="实验简介"><a href="#实验简介" class="headerlink" title="实验简介"></a>实验简介</h2><p>这个实验主要完成TCP Endpoint的功能，一个TCP端点包含一个TCPSender，和一个TCPReceiver。进行TCP连接的时候，通常是一个TCP端点A向另一个TCP端点B发送“连接建立”请求，经过三次握手后TCP连接建立。之后两个端点间可以相互传送数据。每当一端要发送的字节流到达EOF的时候，向对端发送一个“连接关闭”请求，最后当两个端点均已经发送连接关闭的请求，并且都接到了这个请求的响应后，TCP连接就算关闭了。</p><h3 id="TCP状态机"><a href="#TCP状态机" class="headerlink" title="TCP状态机"></a>TCP状态机</h3><p>简介中简单描述了下TCP通信的流程，但具体的TCP状态转移需要考虑一些边界情况，可参考下图，<br><img src="/img/cs144-pic/TCP-FSM.png"></p><h3 id="TCP连接的建立-非同时握手"><a href="#TCP连接的建立-非同时握手" class="headerlink" title="TCP连接的建立(非同时握手)"></a>TCP连接的建立(非同时握手)</h3><p><img src="/img/cs144-pic/TCP-SYN.png"></p><h3 id="TCP连接的关闭-非同时关闭"><a href="#TCP连接的关闭-非同时关闭" class="headerlink" title="TCP连接的关闭(非同时关闭)"></a>TCP连接的关闭(非同时关闭)</h3><p><img src="/img/cs144-pic/TCP-FIN.png"></p><blockquote><p>以上图片均来源于 <a href="https://en.wikipedia.org/wiki/The_Linux_Programming_Interface">Linux&#x2F;UNIX系统编程手册，人民邮电出版社</a></p></blockquote><h2 id="实验思路"><a href="#实验思路" class="headerlink" title="实验思路"></a>实验思路</h2><h3 id="接受报文"><a href="#接受报文" class="headerlink" title="接受报文"></a>接受报文</h3><p>TCP连接从网络上接受报文，并调用<code>segment_received</code>函数。当调用发生时，函数应该如下工作：</p><ol><li>如果收到了 <code>RST</code> 报文，则关闭这个连接，并将接受字节流和发送字节流均设为ERROR状态。否则：</li><li>将报文交给<code>TCPReceiver</code>来处理本报文的包头中的<code>seqno/SYN/FIN</code>和数据段</li><li>如果收到了<code>ACK</code>报文（也就是除了第一个SYN报文外的所有正常报文），通知<code>TCPSender</code>更新<code>ackno</code>和<code>win_size</code></li><li>如果当前报文包含数据或者SYN&#x2F;FIN标志位有效，则至少响应一个报文，以通知对端本端最新的<code>ackno</code>和<code>win_size</code>。</li><li>如果收到了Keepalive报文，见下。</li></ol><h3 id="发送报文"><a href="#发送报文" class="headerlink" title="发送报文"></a>发送报文</h3><ol><li>每当<code>TCPSender</code>将一个TCP报文添加到它的待发送队列中时，TCP连接需要从中取出并将其发送。</li><li>在发送当前数据包之前，TCPConnection 会根据<code>TCPReceiver</code>的<code>ackno</code> 和 <code>win_size</code>，将其放置进待发送 TCPSegment 中，并设置报文的 <code>ACK</code>。</li></ol><h3 id="TCP-KeepAlives"><a href="#TCP-KeepAlives" class="headerlink" title="TCP KeepAlives"></a>TCP KeepAlives</h3><p>KeepAlive是一种周期性检查另一端主机的该TCP连接是否存活的机制。在<a href="https://datatracker.ietf.org/doc/html/rfc1122#page-101">RFC 1122</a> 中被描述。</p><p>KeepAlive报文是一个空的报文段（或者仅包含一个任意字节）。它的序列号等于对端已经ACK过的字节减1: <code>SEG.SEQ = SND.NXT-1</code>，这个序列号对应的数据显然被对方成功接受了，所以不会对对端的接受数据造成影响。如果接受方能正确处理这个KeepAlive报文，则同样返回一个空的<code>ACK</code>报文即可，表明当前TCP连接仍然存活。</p><p>KeepAlive报文和其响应报文都不会包含任何新的有效数据，丢失的时候也不会重传。RFC1122同样指出，仅凭一个没有收到响应的KeepAlive报文不能判断对端的TCP连接已经停止工作，所以失败时需要多次发送Keepalive报文。</p><p>讲义中给出了处理对端KeepAlive报文的伪算法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <span class="hljs-keyword">if</span> (_receiver.<span class="hljs-built_in">ackno</span>().<span class="hljs-built_in">has_value</span>() <span class="hljs-built_in"><span class="hljs-keyword">and</span></span> (seg.<span class="hljs-built_in">length_in_sequence_space</span>() == <span class="hljs-number">0</span>)<br>         <span class="hljs-keyword">and</span> seg.<span class="hljs-built_in">header</span>().seqno == _receiver.<span class="hljs-built_in">ackno</span>().<span class="hljs-built_in">value</span>() - <span class="hljs-number">1</span>) &#123;<br>         _sender.<span class="hljs-built_in">send_empty_segment</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="接受RST报文"><a href="#接受RST报文" class="headerlink" title="接受RST报文"></a>接受RST报文</h3><p>有几种情况本端会收到对端的RST报文</p><ul><li>本端向对端没有打开的端口发送了SYN报文，会收到RST报文。</li><li>TCP连接建立后，对端突然崩溃，本端再发送正常报文时，会收到RST报文。</li><li>TIME-WAIT状态下收到了之前的数据报文，本端正常回复<code>ACK</code>，但对端已经关闭了这个连接，所以会回复一个RST报文（这种情况会导致本端TIME-WAIT状态提前结束，称为<a href="https://www.rfc-editor.org/rfc/rfc1337.html">TIME-WAIT Assassination，在RFC1337中有所描述</a>）</li><li>对端主动发出RST报文</li></ul><p>本端收到了RST报文后，不需要任何回复，直接关闭这条TCP连接，并将发送&#x2F;接受的数据流关闭。（实验中是将 <code>ByteStream inbound/outbound</code>设为 <code>ERROR</code>状态）</p><h3 id="发送RST报文"><a href="#发送RST报文" class="headerlink" title="发送RST报文"></a>发送RST报文</h3><p>上一节已经说明了什么情况下会发送RST报文，但还有以下情况使得一端会主动发出RST报文</p><ul><li>本端socket程序收到了程序终止的信号，如<code>SIGINT</code>，直接发送<code>RST</code>终止连接。</li><li>实验讲义中说明，如果当前重传次数超过上限，则需要<code>RST</code>报文终止连接。</li></ul><p><code>RST</code>报文的<code>seqno</code>部分必须是正确的（正确指的是在对端的接受窗口内，亦即<code>(RCV.NXT &lt;= SEG.SEQ &lt; RCV.NXT+RCV.WND)</code>，<a href="https://datatracker.ietf.org/doc/html/rfc5961#section-3">这样可以防止TCP重置攻击，见RFC5961</a></p><h2 id="调试心得"><a href="#调试心得" class="headerlink" title="调试心得"></a>调试心得</h2><ol><li><p>TCPConnection起始状态是<code>LISTEN</code>，<code>active</code>变量应该为<code>true</code></p><p>测试函数里面，FSM什么都不执行就是LISTEN态。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// tests/tcp_expectation.hh</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Listen</span> :</span> <span class="hljs-keyword">public</span> TCPAction &#123;<br>    <span class="hljs-function">std::string <span class="hljs-title">description</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;listen&quot;</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(TCPTestHarness &amp;)</span> <span class="hljs-keyword">const</span> </span>&#123;&#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p> 我最开始的实现时候<code>_active</code>设为false，<code>t_ack_rst</code> 这个测试包含一个LISTEN态的比较，死活过不去。</p></li><li><p>同时打开</p><p>按照RFC 793的描述，同时打开的情况下，双方第二次握手均应该发送<code>SYN+ACK</code>包，但是测试逻辑这里却希望仅希望收到<code>ACK</code>包</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bnf">    TCP A                                            TCP B<br><br>1.  CLOSED                                           CLOSED<br><br>2.  SYN-SENT     --&gt; <span class="hljs-attribute">&lt;SEQ=100&gt;</span><span class="hljs-attribute">&lt;CTL=SYN&gt;</span>              ...<br><br>3.  SYN-RECEIVED <span class="hljs-attribute">&lt;-- &lt;SEQ=300&gt;</span><span class="hljs-attribute">&lt;CTL=SYN&gt;</span>              <span class="hljs-attribute">&lt;-- SYN-SENT</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">4.               ... &lt;SEQ=100&gt;</span><span class="hljs-attribute">&lt;CTL=SYN&gt;</span>              --&gt; SYN-RECEIVED<br><br>5.  SYN-RECEIVED --&gt; <span class="hljs-attribute">&lt;SEQ=100&gt;</span><span class="hljs-attribute">&lt;ACK=301&gt;</span><span class="hljs-attribute">&lt;CTL=SYN,ACK&gt;</span> ...<br><br>6.  ESTABLISHED  <span class="hljs-attribute">&lt;-- &lt;SEQ=300&gt;</span><span class="hljs-attribute">&lt;ACK=101&gt;</span><span class="hljs-attribute">&lt;CTL=SYN,ACK&gt;</span> <span class="hljs-attribute">&lt;-- SYN-RECEIVED</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">7.               ... &lt;SEQ=101&gt;</span><span class="hljs-attribute">&lt;ACK=301&gt;</span><span class="hljs-attribute">&lt;CTL=ACK&gt;</span>     --&gt; ESTABLISHED<br><br>              Simultaneous Connection Synchronization<br><br>                            Figure 8.<br></code></pre></td></tr></table></figure><p>测试函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TCPTestHarness <span class="hljs-title">test_2</span><span class="hljs-params">(cfg)</span></span>;<br><br>test_2.<span class="hljs-built_in">execute</span>(Connect&#123;&#125;);<br>test_2.<span class="hljs-built_in">execute</span>(<span class="hljs-built_in">Tick</span>(<span class="hljs-number">1</span>));<br><br>TCPSegment seg = test_2.<span class="hljs-built_in">expect_seg</span>(ExpectOneSegment&#123;&#125;.<span class="hljs-built_in">with_syn</span>(<span class="hljs-literal">true</span>).<span class="hljs-built_in">with_ack</span>(<span class="hljs-literal">false</span>),<br>                                    <span class="hljs-string">&quot;test 2 failed: could not parse SYN segment or invalid flags&quot;</span>);<br><span class="hljs-keyword">auto</span> &amp;seg_hdr = seg.<span class="hljs-built_in">header</span>();<br><br>test_2.<span class="hljs-built_in">execute</span>(ExpectState&#123;State::SYN_SENT&#125;);<br><br><span class="hljs-comment">// send SYN (no ACK yet)</span><br><span class="hljs-function"><span class="hljs-keyword">const</span> WrappingInt32 <span class="hljs-title">isn</span><span class="hljs-params">(rd())</span></span>;<br>test_2.<span class="hljs-built_in">send_syn</span>(isn);<br>test_2.<span class="hljs-built_in">execute</span>(<span class="hljs-built_in">Tick</span>(<span class="hljs-number">1</span>));<br><br>test_2.<span class="hljs-built_in">expect_seg</span>(ExpectOneSegment&#123;&#125;.<span class="hljs-built_in">with_syn</span>(<span class="hljs-literal">false</span>).<span class="hljs-built_in">with_ack</span>(<span class="hljs-literal">true</span>).<span class="hljs-built_in">with_ackno</span>(isn + <span class="hljs-number">1</span>),<br>                  <span class="hljs-string">&quot;test 2 failed: bad ACK for SYN&quot;</span>);<br><br>test_2.<span class="hljs-built_in">execute</span>(ExpectState&#123;State::SYN_RCVD&#125;);<br></code></pre></td></tr></table></figure></li><li><p>调试tun144&#x2F;145</p></li></ol><p>本地tun144&#x2F;tun145两张网卡无法通信。tun145发的包tun144收不到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ip a<br>...<br>49: tun144: &lt;NO-CARRIER,POINTOPOINT,MULTICAST,NOARP,UP&gt; mtu 1500 qdisc fq_codel state DOWN group default qlen 500<br>    link/none <br>    inet 169.254.144.1/24 scope global tun144<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::40ad:1e69:28e2:988c/64 scope link stable-privacy <br>       valid_lft forever preferred_lft forever<br>50: tun145: &lt;NO-CARRIER,POINTOPOINT,MULTICAST,NOARP,UP&gt; mtu 1500 qdisc fq_codel state DOWN group default qlen 500<br>    link/none <br>    inet 169.254.145.1/24 scope global tun145<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::8e6c:7fed:e456:8f35/64 scope link stable-privacy <br>       valid_lft forever preferred_lft forever<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ip r<br>default via 10.19.0.254 dev eno1 proto static metric 100 <br>default via 10.30.0.254 dev eno3 proto static metric 20102 <br>10.19.0.0/24 dev eno1 proto kernel scope link src 10.19.0.36 metric 100 <br>10.30.0.0/19 dev eno3 proto kernel scope link src 10.30.19.36 metric 102 <br>169.254.0.0/16 dev tun144 scope link metric 1000 linkdown <br>169.254.144.0/24 dev tun144 scope link linkdown rto_min lock 10ms <br>169.254.145.0/24 dev tun145 scope link linkdown rto_min lock 10ms <br>172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1 <br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo iptables -L -n -t nat   <br>Chain PREROUTING (policy ACCEPT)<br>target     prot opt <span class="hljs-built_in">source</span>               destination         <br>DOCKER     all  --  0.0.0.0/0            0.0.0.0/0            ADDRTYPE match dst-type LOCAL<br>CONNMARK   all  --  169.254.144.0/24     0.0.0.0/0            CONNMARK <span class="hljs-built_in">set</span> 0x90<br>CONNMARK   all  --  169.254.145.0/24     0.0.0.0/0            CONNMARK <span class="hljs-built_in">set</span> 0x91<br><br>Chain INPUT (policy ACCEPT)<br>target     prot opt <span class="hljs-built_in">source</span>               destination         <br><br>Chain OUTPUT (policy ACCEPT)<br>target     prot opt <span class="hljs-built_in">source</span>               destination         <br>DOCKER     all  --  0.0.0.0/0           !127.0.0.0/8          ADDRTYPE match dst-type LOCAL<br><br>Chain POSTROUTING (policy ACCEPT)<br>target     prot opt <span class="hljs-built_in">source</span>               destination         <br>MASQUERADE  all  --  172.17.0.0/16        0.0.0.0/0           <br>MASQUERADE  tcp  --  172.17.0.2           172.17.0.2           tcp dpt:9001<br>MASQUERADE  tcp  --  172.17.0.2           172.17.0.2           tcp dpt:9000<br>MASQUERADE  all  --  0.0.0.0/0            0.0.0.0/0            connmark match  0x90<br>MASQUERADE  all  --  0.0.0.0/0            0.0.0.0/0            connmark match  0x91<br><br>Chain DOCKER (2 references)<br>target     prot opt <span class="hljs-built_in">source</span>               destination         <br>RETURN     all  --  0.0.0.0/0            0.0.0.0/0           <br>DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:9001 to:172.17.0.2:9001<br>DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:9000 to:172.17.0.2:9000<br></code></pre></td></tr></table></figure><ol start="4"><li>Debug打印</li></ol><p>可以加上TCPConnection状态打印函数，为了避免影响性能，存在DEBUG宏的时候编译，或者传给gcc<code>-DDEBUG</code>参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TCPConnectionDebugger</span> &#123;</span><br>      <span class="hljs-keyword">private</span>:<br>        <span class="hljs-keyword">bool</span> open_debugger&#123;<span class="hljs-literal">true</span>&#125;;<br><br>      <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">TCPConnectionDebugger</span>() : <span class="hljs-built_in">open_debugger</span>(<span class="hljs-literal">true</span>) &#123;&#125;<br>        ~<span class="hljs-built_in">TCPConnectionDebugger</span>() &#123;&#125;<br><br>        <span class="hljs-function">std::string <span class="hljs-title">color_1</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::string &amp;data)</span> </span>&#123; <span class="hljs-keyword">return</span> data; &#125;<br><br>        <span class="hljs-function">std::string <span class="hljs-title">color_2</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::string &amp;data)</span> </span>&#123; <span class="hljs-keyword">return</span> data; &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_segment</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCPConnection &amp;that,</span></span><br><span class="hljs-params"><span class="hljs-function">                           <span class="hljs-keyword">const</span> TCPSegment &amp;seg,</span></span><br><span class="hljs-params"><span class="hljs-function">                           <span class="hljs-keyword">const</span> std::string &amp;desription,</span></span><br><span class="hljs-params"><span class="hljs-function">                           <span class="hljs-keyword">bool</span> check = <span class="hljs-literal">true</span>)</span> </span>&#123;<br>            <span class="hljs-built_in">DUMMY_CODE</span>(that, seg, desription, check);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> DEBUG</span><br>            std::cerr &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span> &lt;&lt; <span class="hljs-built_in">color_1</span>(desription) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>            std::cerr &lt;&lt; (<span class="hljs-built_in">color_2</span>(<span class="hljs-string">&quot;Flag&quot;</span>) + <span class="hljs-string">&quot; : &quot;</span>) &lt;&lt; (seg.<span class="hljs-built_in">header</span>().syn ? <span class="hljs-string">&quot;S&quot;</span> : <span class="hljs-string">&quot;&quot;</span>) &lt;&lt; (seg.<span class="hljs-built_in">header</span>().fin ? <span class="hljs-string">&quot;F&quot;</span> : <span class="hljs-string">&quot;&quot;</span>)<br>                      &lt;&lt; (seg.<span class="hljs-built_in">header</span>().ack ? <span class="hljs-string">&quot;A&quot;</span> : <span class="hljs-string">&quot;&quot;</span>) &lt;&lt; (seg.<span class="hljs-built_in">header</span>().rst ? <span class="hljs-string">&quot;R&quot;</span> : <span class="hljs-string">&quot;&quot;</span>) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span><br>                      &lt;&lt; (<span class="hljs-built_in">color_2</span>(<span class="hljs-string">&quot;Sequnce Number&quot;</span>) + <span class="hljs-string">&quot; : &quot;</span>) &lt;&lt; (seg.<span class="hljs-built_in">header</span>().seqno.<span class="hljs-built_in">raw_value</span>()) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span><br>                      &lt;&lt; (<span class="hljs-built_in">color_2</span>(<span class="hljs-string">&quot;Acknowledgement Number&quot;</span>) + <span class="hljs-string">&quot; : &quot;</span>) &lt;&lt; (seg.<span class="hljs-built_in">header</span>().ackno) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span><br>                      &lt;&lt; (<span class="hljs-built_in">color_2</span>(<span class="hljs-string">&quot;Window Size&quot;</span>) + <span class="hljs-string">&quot; : &quot;</span>) &lt;&lt; (seg.<span class="hljs-built_in">header</span>().win) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span><br>                      &lt;&lt; (<span class="hljs-built_in">color_2</span>(<span class="hljs-string">&quot;Payload&quot;</span>) + <span class="hljs-string">&quot; : &quot;</span>) &lt;&lt; (seg.<span class="hljs-built_in">payload</span>().<span class="hljs-built_in">size</span>() ? seg.<span class="hljs-built_in">payload</span>().<span class="hljs-built_in">str</span>() : <span class="hljs-string">&quot;empty string&quot;</span>)<br>                      &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span><br>                      &lt;&lt; (<span class="hljs-built_in">color_2</span>(<span class="hljs-string">&quot;Payload Size&quot;</span>) + <span class="hljs-string">&quot; : &quot;</span>) &lt;&lt; (seg.<span class="hljs-built_in">payload</span>().<span class="hljs-built_in">size</span>()) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span><br>                      &lt;&lt; (<span class="hljs-built_in">color_2</span>(<span class="hljs-string">&quot;Sequnce Space&quot;</span>) + <span class="hljs-string">&quot; : &quot;</span>) &lt;&lt; (seg.<span class="hljs-built_in">length_in_sequence_space</span>()) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span><br>                      &lt;&lt; (<span class="hljs-built_in">color_2</span>(<span class="hljs-string">&quot;ackno of sender&quot;</span>) + <span class="hljs-string">&quot; : &quot;</span>) &lt;&lt; (that._sender.<span class="hljs-built_in">next_seqno_absolute</span>()) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span><br>                      &lt;&lt; (<span class="hljs-built_in">color_2</span>(<span class="hljs-string">&quot;next seqno absolute of sender&quot;</span>) + <span class="hljs-string">&quot; : &quot;</span>) &lt;&lt; (that._sender.<span class="hljs-built_in">next_seqno_absolute</span>())<br>                      &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>            std::cerr &lt;&lt; (<span class="hljs-built_in">color_2</span>(<span class="hljs-string">&quot;Active: &quot;</span>) + ((that._active) ? <span class="hljs-string">&quot;Y &quot;</span> : <span class="hljs-string">&quot;N&quot;</span>))<br>                      &lt;&lt; (<span class="hljs-built_in">color_2</span>(<span class="hljs-string">&quot;  TIME_WAIT: &quot;</span>) + ((that._linger_after_streams_finish) ? <span class="hljs-string">&quot;Y\n&quot;</span> : <span class="hljs-string">&quot;N\n&quot;</span>));<br>            std::cerr &lt;&lt; (<span class="hljs-built_in">color_2</span>(<span class="hljs-string">&quot;Sender State: &quot;</span>)) &lt;&lt; that.<span class="hljs-built_in">state</span>().<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>        &#125;<br>    &#125;;<br><br></code></pre></td></tr></table></figure><h2 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h2><ol><li>第一次实现的性能<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./apps/tcp_benchmark<br>CPU-limited throughput                : 2.65 Gbit/s<br>CPU-limited throughput with reordering: 1.45 Gbit/s<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>CS144</tag>
      
      <tag>TCP/IP</tag>
      
      <tag>Networking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust标准库涉及的Trait</title>
    <link href="/202205/rust-traits/"/>
    <url>/202205/rust-traits/</url>
    
    <content type="html"><![CDATA[<p>本篇文章是对下面文章的阅读笔记，不保证可靠性，希望大家还是以Rust标准库源码&#x2F;英文原文为准</p><p><a href="https://github.com/pretzelhammer/rust-blog/blob/master/posts/tour-of-rusts-standard-library-traits.md">Tour of Rust’s Standard Library Traits</a></p><p>本文亦参考了下面这篇文章，但该文章排版有混乱的地方<br><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_7/rusts-standard-library-traits.html">Tour of Rust’s Standard Library Traits中译</a></p><h2 id="Trait基础"><a href="#Trait基础" class="headerlink" title="Trait基础"></a>Trait基础</h2><h3 id="1-Self指代实现的类型"><a href="#1-Self指代实现的类型" class="headerlink" title="1. Self指代实现的类型"></a>1. Self指代实现的类型</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Trait</span></span> &#123;<br>    <span class="hljs-comment">// always returns i32</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">returns_num</span></span>() -&gt; <span class="hljs-built_in">i32</span>;<br><br>    <span class="hljs-comment">// returns implementing type</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">returns_self</span></span>() -&gt; <span class="hljs-keyword">Self</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SomeType</span></span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">OtherType</span></span>;<br><br><span class="hljs-keyword">impl</span> Trait <span class="hljs-keyword">for</span> SomeType &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">returns_num</span></span>() -&gt; <span class="hljs-built_in">i32</span> &#123;<br>        <span class="hljs-number">5</span><br>    &#125;<br><br>    <span class="hljs-comment">// Self == SomeType</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">returns_self</span></span>() -&gt; <span class="hljs-keyword">Self</span> &#123;<br>        SomeType<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-Function"><a href="#2-Function" class="headerlink" title="2. Function"></a>2. Function</h3><ol><li>指代第一个参数不是self的任意函数，类似其他语言的静态函数</li><li>只能通过 Typename::func() 方式调用。这里的type实现了trait</li></ol><h3 id="3-Method"><a href="#3-Method" class="headerlink" title="3. Method"></a>3. Method</h3><ol><li><p>指的是第一个参数是self的函数。其类型是 <code>Self</code> ， <code>&amp;Self</code>或 <code>&amp;mut Self</code>。也可以被Box，Rc，Arc或Pin来包装。</p></li><li><p>通过 TraitName::func() 方式调用，或者 &lt;实现trait类型的实例&gt;.func() 调用</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> five = <span class="hljs-built_in">ToString</span>::to_string(&amp;<span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">let</span> five = <span class="hljs-built_in">i32</span>::to_string(&amp;<span class="hljs-number">5</span>);<br>&#125;<br><span class="hljs-comment">// 5这里是i32类型，i32类型实现了ToString trait</span><br><span class="hljs-comment">// https://doc.rust-lang.org/std/string/trait.ToString.html</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> five = <span class="hljs-number">5</span>.to_string();<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><h3 id="4-Associated-Types-关联类型"><a href="#4-Associated-Types-关联类型" class="headerlink" title="4. Associated Types 关联类型"></a>4. Associated Types 关联类型</h3><ol><li><p>每个类型对这个trait的实现中，可以由实现者指定func中某个参数的类型</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Trait</span></span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">AssociatedType</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">func</span></span>(arg: Self::AssociatedType);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SomeType</span></span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">OtherType</span></span>;<br><br><span class="hljs-comment">// any type implementing Trait can</span><br><span class="hljs-comment">// choose the type of AssociatedType</span><br><br><span class="hljs-keyword">impl</span> Trait <span class="hljs-keyword">for</span> SomeType &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">AssociatedType</span></span> = <span class="hljs-built_in">i8</span>; <span class="hljs-comment">// chooses i8</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">func</span></span>(arg: Self::AssociatedType) &#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> Trait <span class="hljs-keyword">for</span> OtherType &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">AssociatedType</span></span> = <span class="hljs-built_in">u8</span>; <span class="hljs-comment">// chooses u8</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">func</span></span>(arg: Self::AssociatedType) &#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    SomeType::func(-<span class="hljs-number">1_i8</span>); <span class="hljs-comment">// can only call func with i8 on SomeType</span><br>    OtherType::func(<span class="hljs-number">1_u8</span>); <span class="hljs-comment">// can only call func with u8 on OtherType</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="5-Generic-Parameters-泛型参数"><a href="#5-Generic-Parameters-泛型参数" class="headerlink" title="5. Generic Parameters 泛型参数"></a>5. Generic Parameters 泛型参数</h3><ol><li><p>“泛型参数”泛指</p><ol><li>泛型类型参数（generic type parameters）</li><li>泛型生命周期参数（generic lifetime parameters）</li><li>泛型常量参数（generic const parameters）</li></ol></li><li><p>因为这些说起来比较拗口，所以人们通常把它们简称为 “泛型类型（generic type）”、“生命周期（lifetime）”和 “泛型常量（generic const）”。</p></li><li><p>本文不讨论泛型常量</p></li><li><p>一个泛型类型 + 生命周期的例子，可以通过&lt;T &#x3D; i32&gt; 的方式赋默认类型</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// trait declaration generalized with lifetime &amp; type parameters</span><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Trait</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt; &#123;<br>    <span class="hljs-comment">// signature uses generic type</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">func1</span></span>(arg: T);<br><br>    <span class="hljs-comment">// signature uses lifetime</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">func2</span></span>(arg: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">i32</span>);<br><br>    <span class="hljs-comment">// signature uses generic type &amp; lifetime</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">func3</span></span>(arg: &amp;<span class="hljs-symbol">&#x27;a</span> T);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SomeType</span></span>;<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; Trait&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-built_in">i8</span>&gt; <span class="hljs-keyword">for</span> SomeType &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">func1</span></span>(arg: <span class="hljs-built_in">i8</span>) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">func2</span></span>(arg: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">i32</span>) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">func3</span></span>(arg: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-built_in">i8</span>) &#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;b</span>&gt; Trait&lt;<span class="hljs-symbol">&#x27;b</span>, <span class="hljs-built_in">u8</span>&gt; <span class="hljs-keyword">for</span> SomeType &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">func1</span></span>(arg: <span class="hljs-built_in">u8</span>) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">func2</span></span>(arg: &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-built_in">i32</span>) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">func3</span></span>(arg: &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-built_in">u8</span>) &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// any type can be used as the default</span><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Trait2</span></span>&lt;T = <span class="hljs-built_in">i32</span>&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">func2</span></span>(t: T) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>也可以只对trait中的单个函数&#x2F;方法泛型化</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Trait</span></span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">func</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt;(t: &amp;<span class="hljs-symbol">&#x27;a</span> T);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="6-泛型-vs-关联类型"><a href="#6-泛型-vs-关联类型" class="headerlink" title="6. 泛型 vs 关联类型"></a>6. 泛型 vs 关联类型</h3><p>相同点：</p><ul><li>都把在 trait 的函数和方法中使用哪种具体类型的决定权交给了实现者</li></ul><p>不同点：</p><ul><li>当每个类型只应该有 trait 的一个实现时，使用关联类型。</li><li>当每个类型可能会有 trait 的多个实现时，使用泛型类型。</li></ul><ol><li>一个例子 Point 类型实现了Add这个trait，目前实现采用了关联类型，因此只能实现对一个类型的add func 实现Point类型对i32类型的add 方法会报错 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Add</span></span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Rhs</span></span>;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Output</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">add</span></span>(<span class="hljs-keyword">self</span>, rhs: Self::Rhs) -&gt; Self::Output;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span></span> &#123;<br>    x: <span class="hljs-built_in">i32</span>,<br>    y: <span class="hljs-built_in">i32</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> Add <span class="hljs-keyword">for</span> Point &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Rhs</span></span> = Point;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Output</span></span> = Point;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">add</span></span>(<span class="hljs-keyword">self</span>, rhs: Point) -&gt; Point &#123;<br>        Point &#123;<br>            x: <span class="hljs-keyword">self</span>.x + rhs.x,<br>            y: <span class="hljs-keyword">self</span>.y + rhs.y,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> Add <span class="hljs-keyword">for</span> Point &#123; <span class="hljs-comment">// ❌</span><br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Rhs</span></span> = <span class="hljs-built_in">i32</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Output</span></span> = Point;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">add</span></span>(<span class="hljs-keyword">self</span>, rhs: <span class="hljs-built_in">i32</span>) -&gt; Point &#123;<br>        Point &#123;<br>            x: <span class="hljs-keyword">self</span>.x + rhs,<br>            y: <span class="hljs-keyword">self</span>.y + rhs,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> p1 = Point &#123; x: <span class="hljs-number">1</span>, y: <span class="hljs-number">1</span> &#125;;<br>    <span class="hljs-keyword">let</span> p2 = Point &#123; x: <span class="hljs-number">2</span>, y: <span class="hljs-number">2</span> &#125;;<br>    <span class="hljs-keyword">let</span> p3 = p1.add(p2);<br>    <span class="hljs-built_in">assert_eq!</span>(p3.x, <span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(p3.y, <span class="hljs-number">3</span>);<br><br>    <span class="hljs-keyword">let</span> p1 = Point &#123; x: <span class="hljs-number">1</span>, y: <span class="hljs-number">1</span> &#125;;<br>    <span class="hljs-keyword">let</span> int2 = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">let</span> p3 = p1.add(int2); <span class="hljs-comment">// ❌</span><br>    <span class="hljs-built_in">assert_eq!</span>(p3.x, <span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(p3.y, <span class="hljs-number">3</span>);<br>&#125;<br></code></pre></td></tr></table></figure> 所以这里需要使用泛型来支持“多个类型在trait中的func会有多个实现“ 这里output也是关联类型，因此所有func实现的Output只能是一个类型 如果实现“点 + 点 &#x3D; 线段”这种其他Output类型，则会报错。解决方法就是把Output也换成泛型 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Add</span></span>&lt;Rhs&gt; &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Output</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">add</span></span>(<span class="hljs-keyword">self</span>, rhs: Rhs) -&gt; Self::Output;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span></span> &#123;<br>    x: <span class="hljs-built_in">i32</span>,<br>    y: <span class="hljs-built_in">i32</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> Add&lt;Point&gt; <span class="hljs-keyword">for</span> Point &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Output</span></span> = <span class="hljs-keyword">Self</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">add</span></span>(<span class="hljs-keyword">self</span>, rhs: Point) -&gt; Self::Output &#123;<br>        Point &#123;<br>            x: <span class="hljs-keyword">self</span>.x + rhs.x,<br>            y: <span class="hljs-keyword">self</span>.y + rhs.y,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> Add&lt;<span class="hljs-built_in">i32</span>&gt; <span class="hljs-keyword">for</span> Point &#123; <span class="hljs-comment">// ✅</span><br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Output</span></span> = <span class="hljs-keyword">Self</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">add</span></span>(<span class="hljs-keyword">self</span>, rhs: <span class="hljs-built_in">i32</span>) -&gt; Self::Output &#123;<br>        Point &#123;<br>            x: <span class="hljs-keyword">self</span>.x + rhs,<br>            y: <span class="hljs-keyword">self</span>.y + rhs,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> p1 = Point &#123; x: <span class="hljs-number">1</span>, y: <span class="hljs-number">1</span> &#125;;<br>    <span class="hljs-keyword">let</span> p2 = Point &#123; x: <span class="hljs-number">2</span>, y: <span class="hljs-number">2</span> &#125;;<br>    <span class="hljs-keyword">let</span> p3 = p1.add(p2);<br>    <span class="hljs-built_in">assert_eq!</span>(p3.x, <span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(p3.y, <span class="hljs-number">3</span>);<br><br>    <span class="hljs-keyword">let</span> p1 = Point &#123; x: <span class="hljs-number">1</span>, y: <span class="hljs-number">1</span> &#125;;<br>    <span class="hljs-keyword">let</span> int2 = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">let</span> p3 = p1.add(int2); <span class="hljs-comment">// ✅</span><br>    <span class="hljs-built_in">assert_eq!</span>(p3.x, <span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(p3.y, <span class="hljs-number">3</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="7-作用域"><a href="#7-作用域" class="headerlink" title="7. 作用域"></a>7. 作用域</h3><ol><li><p>Trait 只有被显式地导入，才能使用其中定义的func</p><p> 比如Read trait就需要导入才能用</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">use</span> std::io;<br><span class="hljs-keyword">use</span> std::io::Read; <span class="hljs-comment">// ✅</span><br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; <span class="hljs-built_in">Result</span>&lt;(), io::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> file = File::open(<span class="hljs-string">&quot;Cargo.toml&quot;</span>)?;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> buffer = <span class="hljs-built_in">String</span>::new();<br>    file.read_to_string(&amp;<span class="hljs-keyword">mut</span> buffer)?; <span class="hljs-comment">// ✅</span><br>    <span class="hljs-literal">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>标准库预置是个例外，总是被隐式导入。（The standard library prelude）是标准库中的一个模块，也就是说，<code>std::prelude::v1</code>，它在每个其他模块的顶部被自动导入，即<code>use std::prelude::v1::*</code>。这样的话，下面这些 trait 就总会在作用域中，我们不需要自己显式地导入它们，因为它们是预置的一部分。</p><ul><li>AsMut</li><li>AsRef</li><li>Clone</li><li>Copy</li><li>Default</li><li>Drop</li><li>Eq</li><li>Fn</li><li>FnMut</li><li>FnOnce</li><li>From</li><li>Into</li><li>ToOwned</li><li>IntoIterator</li><li>Iterator</li><li>PartialEq</li><li>PartialOrd</li><li>Send</li><li>Sized</li><li>Sync</li><li>ToString</li><li>Ord</li></ul></li></ol><h3 id="8-派生宏（Derive-Macros）"><a href="#8-派生宏（Derive-Macros）" class="headerlink" title="8.  派生宏（Derive Macros）"></a>8.  派生宏（Derive Macros）</h3><p>标准库导出了一小部分派生宏，这么派生宏可以让我们可以便捷地在一个类型上实现 trait，前提是该类型的所有成员都实现了这个 trait。派生宏以它们所实现的 trait 来命名。</p><ul><li>Clone</li><li>Copy</li><li>Debug</li><li>Default</li><li>Eq</li><li>Hash</li><li>Ord</li><li>PartialEq</li><li>PartialOrd</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// macro derives Copy &amp; Clone impl for SomeType</span><br><span class="hljs-meta">#[derive(Copy, Clone)]</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SomeType</span></span>;<br></code></pre></td></tr></table></figure><h3 id="9-Default-impls-默认实现"><a href="#9-Default-impls-默认实现" class="headerlink" title="9. Default impls 默认实现"></a>9. Default impls 默认实现</h3><ol><li><p>trait可以为定义的函数&#x2F;方法提供默认实现</p><p> 标准库中的很多 trait 为很多它们的方法提供了默认实现。</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Trait</span></span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">method</span></span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;default impl&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SomeType</span></span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">OtherType</span></span>;<br><br><span class="hljs-comment">// use default impl for Trait::method</span><br><span class="hljs-keyword">impl</span> Trait <span class="hljs-keyword">for</span> SomeType &#123;&#125;<br><br><span class="hljs-keyword">impl</span> Trait <span class="hljs-keyword">for</span> OtherType &#123;<br>    <span class="hljs-comment">// use our own impl for Trait::method</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">method</span></span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;OtherType impl&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    SomeType.method(); <span class="hljs-comment">// prints &quot;default impl&quot;</span><br>    OtherType.method(); <span class="hljs-comment">// prints &quot;OtherType impl&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="10-Generic-Blanket-Impls-泛型覆盖实现"><a href="#10-Generic-Blanket-Impls-泛型覆盖实现" class="headerlink" title="10. Generic Blanket Impls 泛型覆盖实现"></a>10. <strong><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_7/rusts-standard-library-traits.html#%E6%B3%9B%E5%9E%8B%E8%A6%86%E7%9B%96%E5%AE%9E%E7%8E%B0generic-blanket-impls">Generic Blanket Impls</a> 泛型覆盖实现</strong></h3><ol><li>trait中的方法&#x2F;函数可以定义一个泛型实现<ol><li><p>一个例子</p><ol><li>类型T满足<code>Rem&lt;Output = T&gt; + PartialEq&lt;T&gt; + Sized,</code> 且类型u8可以转换为类型T</li></ol> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#![allow(unused)]</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br><span class="hljs-keyword">use</span> std::fmt::<span class="hljs-built_in">Debug</span>;<br><span class="hljs-keyword">use</span> std::convert::TryInto;<br><span class="hljs-keyword">use</span> std::ops::Rem;<br><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Even</span></span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">is_even</span></span>(<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">bool</span>;<br>&#125;<br><br><span class="hljs-comment">// generic blanket impl</span><br><span class="hljs-keyword">impl</span>&lt;T&gt; Even <span class="hljs-keyword">for</span> T<br><span class="hljs-keyword">where</span><br>    T: Rem&lt;Output = T&gt; + <span class="hljs-built_in">PartialEq</span>&lt;T&gt; + <span class="hljs-built_in">Sized</span>,<br>    <span class="hljs-built_in">u8</span>: TryInto&lt;T&gt;,<br>    &lt;<span class="hljs-built_in">u8</span> <span class="hljs-keyword">as</span> TryInto&lt;T&gt;&gt;::Error: <span class="hljs-built_in">Debug</span>,<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">is_even</span></span>(<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">bool</span> &#123;<br>        <span class="hljs-comment">// these unwraps will never panic</span><br>        <span class="hljs-keyword">self</span> % <span class="hljs-number">2</span>.try_into().unwrap() == <span class="hljs-number">0</span>.try_into().unwrap()<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">#[test]</span> <span class="hljs-comment">// ✅</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">test_is_even</span></span>() &#123;<br>    <span class="hljs-built_in">assert!</span>(<span class="hljs-number">2_i8</span>.is_even());<br>    <span class="hljs-built_in">assert!</span>(<span class="hljs-number">4_u8</span>.is_even());<br>    <span class="hljs-built_in">assert!</span>(<span class="hljs-number">6_i16</span>.is_even());<br>    <span class="hljs-comment">// etc</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>泛型覆盖实现提供了方法的实现，所以它们不能被重写。</p><p> trait 一致性是指，对于任意给定的类型，最多存在某一 trait 的一个实现。Rust 用来强制执行特质一致性的规则，这些规则的含义，以及针对这些含义的变通方案都不在本文的讨论范围之内。</p></li></ol></li></ol><h3 id="11-Subtraits-amp-Supertraits"><a href="#11-Subtraits-amp-Supertraits" class="headerlink" title="11. Subtraits &amp; Supertraits"></a>11. <strong><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_7/rusts-standard-library-traits.html#subtraits--supertraits">Subtraits &amp; Supertraits</a></strong></h3><p>子集、超集</p><ol><li><p>考虑如下的例子</p><ol><li>所有实现了Subtrait的类型是所有实现了Supertrait的类型的子集，或者反过来讲：所有实现了Supertrait的类型是所有实现了Subtrait类型的子集。</li></ol> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Subtrait</span></span>: Supertrait &#123;&#125;<br></code></pre></td></tr></table></figure><p> 它等于</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Subtrait</span></span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">Self</span>: Supertrait &#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>子集和超集说的是的是实现trait的类型：</p><ol><li>也就是说约束在<code>Self</code>上：实现<code>Subtrait</code>的类型</li></ol> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Supertrait</span></span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">method</span></span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;in supertrait&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Subtrait</span></span>: Supertrait &#123;<br>    <span class="hljs-comment">// this looks like it might impl or</span><br>    <span class="hljs-comment">// override Supertrait::method but it</span><br>    <span class="hljs-comment">// does not</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">method</span></span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;in subtrait&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SomeType</span></span>;<br><br><span class="hljs-comment">// adds Supertrait::method to SomeType</span><br><span class="hljs-keyword">impl</span> Supertrait <span class="hljs-keyword">for</span> SomeType &#123;&#125;<br><br><span class="hljs-comment">// adds Subtrait::method to SomeType</span><br><span class="hljs-keyword">impl</span> Subtrait <span class="hljs-keyword">for</span> SomeType &#123;&#125;<br><br><span class="hljs-comment">// both methods exist on SomeType simultaneously</span><br><span class="hljs-comment">// neither overriding or shadowing the other</span><br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    SomeType.method(); <span class="hljs-comment">// ❌ ambiguous method call</span><br>    <span class="hljs-comment">// must disambiguate using fully-qualified syntax</span><br>    &lt;SomeType <span class="hljs-keyword">as</span> Supertrait&gt;::method(&amp;st); <span class="hljs-comment">// ✅ prints &quot;in supertrait&quot;</span><br>    &lt;SomeType <span class="hljs-keyword">as</span> Subtrait&gt;::method(&amp;st); <span class="hljs-comment">// ✅ prints &quot;in subtrait&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>需要区分：对泛型进行约束</p><ol><li><p>下面例子中，t的类型T一定实现了Clone Trait，或者说“类型T依赖Clone trait”，称为：泛型依赖于 trait 约束。</p><ol><li>在function中，t.clone() 可以被调用（定义在Clone trait的func都可以被调用）</li></ol> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">function</span></span>&lt;T: <span class="hljs-built_in">Clone</span>&gt;(t: T) &#123;<br>    <span class="hljs-comment">// impl</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>子集和超集</p><ol><li><p>Copy Trait 的例子</p><ol><li><p>Copy是Clone的子集，Copy并不依赖Clone</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Copy</span></span>: <span class="hljs-built_in">Clone</span> &#123;&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>可以这么理解：subtrait 细化（refine）了它们的 supertrait。</p><p> “细化（Refinement）”刻意保持一定的模糊性，因为它们在不同的上下文环境中会有不同的含义：</p><ul><li>subtrait 可能会使得 supertrait 的方法实现更为具体，快速，占用更少的内存，例如，<code>Copy:Clone</code>；</li><li>subtrait 可能会对 supertrait 的方法实现增加额外的保证，例如：<code>Eq: PartialEq</code>,<code>Ord: PartialOrd</code>,<code>ExactSizeIterator: Iterator</code>;</li><li>subtrait 可能会使得 supertrait 的方法更为灵活和易于调用，例如：<code>FnMut: FnOnce</code>,<code>Fn: FnMut</code>;</li><li>subtrait 可能会扩展 supertrait 并添加新的方法，例如：<code>DoubleEndedIterator: Iterator</code>,<code>ExactSizeIterator: Iterator</code>。</li></ul></li></ol><blockquote><p>感觉这里的“细化”可以理解为“特例化” zelin 220513</p></blockquote></li></ol><h3 id="12-Trait对象"><a href="#12-Trait对象" class="headerlink" title="12. Trait对象"></a>12. Trait对象</h3><ol><li><p>泛型可以实现编译期多态，Trait对象可以实现运行时多态</p></li><li><p>一个使用trait对象是函数动态返回不同类型的例子</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">example</span></span>(condition: <span class="hljs-built_in">bool</span>, vec: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">i32</span>&gt;) -&gt; <span class="hljs-built_in">Box</span>&lt;<span class="hljs-keyword">dyn</span> <span class="hljs-built_in">Iterator</span>&lt;Item = <span class="hljs-built_in">i32</span>&gt;&gt; &#123;<br>    <span class="hljs-keyword">let</span> iter = vec.into_iter();<br>    <span class="hljs-keyword">if</span> condition &#123;<br>        <span class="hljs-comment">// Has type:</span><br>        <span class="hljs-comment">// Box&lt;Map&lt;IntoIter&lt;i32&gt;, Fn(i32) -&gt; i32&gt;&gt;</span><br>        <span class="hljs-comment">// But is cast to:</span><br>        <span class="hljs-comment">// Box&lt;dyn Iterator&lt;Item = i32&gt;&gt;</span><br>        <span class="hljs-built_in">Box</span>::new(iter.map(|n| n * <span class="hljs-number">2</span>))<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Has type:</span><br>        <span class="hljs-comment">// Box&lt;Filter&lt;IntoIter&lt;i32&gt;, Fn(&amp;i32) -&gt; bool&gt;&gt;</span><br>        <span class="hljs-comment">// But is cast to:</span><br>        <span class="hljs-comment">// Box&lt;dyn Iterator&lt;Item = i32&gt;&gt;</span><br>        <span class="hljs-built_in">Box</span>::new(iter.filter(|&amp;n| n &gt;= <span class="hljs-number">2</span>))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>一个使用trait对象在集合中存储不同类型的例子</p><p> 这些类型都实现了同一个trait</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#![allow(unused)]</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br><span class="hljs-keyword">use</span> std::<span class="hljs-built_in">f64</span>::consts::PI;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Circle</span></span> &#123;<br>    radius: <span class="hljs-built_in">f64</span>,<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Square</span></span> &#123;<br>    side: <span class="hljs-built_in">f64</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Shape</span></span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">area</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">f64</span>;<br>&#125;<br><br><span class="hljs-keyword">impl</span> Shape <span class="hljs-keyword">for</span> Circle &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">area</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">f64</span> &#123;<br>        PI * <span class="hljs-keyword">self</span>.radius * <span class="hljs-keyword">self</span>.radius<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> Shape <span class="hljs-keyword">for</span> Square &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">area</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">f64</span> &#123;<br>        <span class="hljs-keyword">self</span>.side * <span class="hljs-keyword">self</span>.side<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_total_area</span></span>(shapes: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">Box</span>&lt;<span class="hljs-keyword">dyn</span> Shape&gt;&gt;) -&gt; <span class="hljs-built_in">f64</span> &#123;<br>    shapes.into_iter().map(|s| s.area()).sum()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">example</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> shapes: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">Box</span>&lt;<span class="hljs-keyword">dyn</span> Shape&gt;&gt; = <span class="hljs-built_in">vec!</span>[<br>        <span class="hljs-built_in">Box</span>::new(Circle &#123; radius: <span class="hljs-number">1.0</span> &#125;), <span class="hljs-comment">// Box&lt;Circle&gt; cast to Box&lt;dyn Shape&gt;</span><br>        <span class="hljs-built_in">Box</span>::new(Square &#123; side: <span class="hljs-number">1.0</span> &#125;), <span class="hljs-comment">// Box&lt;Square&gt; cast to Box&lt;dyn Shape&gt;</span><br>    ];<br>    <span class="hljs-built_in">assert_eq!</span>(PI + <span class="hljs-number">1.0</span>, get_total_area(shapes)); <span class="hljs-comment">// ✅</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Trait对象是没有大小的，所以必须用智能指针包裹trait对象</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Struct</span></span>;<br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Trait</span></span> &#123;&#125;<br><br><span class="hljs-comment">// regular struct</span><br>&amp;Struct<br><span class="hljs-built_in">Box</span>&lt;Struct&gt;<br>Rc&lt;Struct&gt;<br>Arc&lt;Struct&gt;<br><br><span class="hljs-comment">// trait objects</span><br>&amp;<span class="hljs-keyword">dyn</span> Trait<br><span class="hljs-built_in">Box</span>&lt;<span class="hljs-keyword">dyn</span> Trait&gt;<br>Rc&lt;<span class="hljs-keyword">dyn</span> Trait&gt;<br>Arc&lt;<span class="hljs-keyword">dyn</span> Trait&gt;<br></code></pre></td></tr></table></figure></li><li><p>不是所有的 trait 都可以被转成 trait 对象。当且仅当一个 trait 满足下面这些要求时，它才是对象安全的（object-safe）：</p><ul><li>trait 不要求<code>Self:Sized</code></li><li>trait 的所有方法都是对象安全的</li></ul><p> 当一个 trait 方法满足下面的要求时，该方法是对象安全的：</p><ul><li>方法要求<code>Self:Sized</code> 或者</li><li>方法在其接收者位置仅使用一个<code>Self</code>类型</li></ul></li></ol><h3 id="13-Maker-Traits"><a href="#13-Maker-Traits" class="headerlink" title="13. Maker Traits"></a>13. Maker Traits</h3><p>指的是没有trait item（项）的trait（即没有任何函数&#x2F;方法）</p><p>仅仅是“标记”功能：类型具有“某种属性”</p><p>Eq就是一个标记Trait，在PartialEq基础上标记了“额外具有反射性”</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// Impling PartialEq for a type promises</span><br><span class="hljs-comment">// that equality for the type has these properties:</span><br><span class="hljs-comment">// - symmetry: a == b implies b == a, and</span><br><span class="hljs-comment">// - transitivity: a == b &amp;&amp; b == c implies a == c</span><br><span class="hljs-comment">// But DOES NOT promise this property:</span><br><span class="hljs-comment">// - reflexivity: a == a</span><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">PartialEq</span></span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">eq</span></span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;<span class="hljs-keyword">Self</span>) -&gt; <span class="hljs-built_in">bool</span>;<br>&#125;<br><br><span class="hljs-comment">// Eq has no trait items! The eq method is already</span><br><span class="hljs-comment">// declared by PartialEq, but &quot;impling&quot; Eq</span><br><span class="hljs-comment">// for a type promises this additional equality property:</span><br><span class="hljs-comment">// - reflexivity: a == a</span><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Eq</span></span>: <span class="hljs-built_in">PartialEq</span> &#123;&#125;<br><br><span class="hljs-comment">// f64 impls PartialEq but not Eq because NaN != NaN</span><br><span class="hljs-comment">// i32 impls PartialEq &amp; Eq because there&#x27;s no NaNs :)</span><br></code></pre></td></tr></table></figure><h3 id="14-Auto-Trait-自动Trait"><a href="#14-Auto-Trait-自动Trait" class="headerlink" title="14. Auto Trait: 自动Trait"></a>14. Auto Trait: 自动Trait</h3><ol><li><p>自动 Trait 是指如果一个类型的所有成员都实现了该 trait，该类型就会自动实现该 trait。</p></li><li><p>“成员（member）”的含义取决于类型，例如：结构体的字段、枚举的变量、数组的元素、元组的项，等等</p></li><li><p>自动 trait 必须是标记 trait，但不是所有标记trait都是自动trait</p></li><li><p>自动trait的例子</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// implemented for types which are safe to send between threads</span><br><span class="hljs-keyword">unsafe</span> auto <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Send</span></span> &#123;&#125;<br><br><span class="hljs-comment">// implemented for types whose references are safe to send between threads</span><br><span class="hljs-keyword">unsafe</span> auto <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Sync</span></span> &#123;&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="15-unsafe-Trait"><a href="#15-unsafe-Trait" class="headerlink" title="15. unsafe Trait"></a>15. unsafe Trait</h3><ol><li><p>trait 可以被标记为unsafe，指的是实现trait的时候可以带一些unsafe代码</p></li><li><p>Send Sync这两个Trait就是unsafe Trait。如果手动实现Send Sync这两个Trait的时候，需要加上unsafe</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// SomeType is not Send or Sync</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SomeType</span></span> &#123;<br>    not_send_or_sync: *<span class="hljs-keyword">const</span> (),<br>&#125;<br><br><span class="hljs-comment">// but if we&#x27;re confident that our impl doesn&#x27;t have any data</span><br><span class="hljs-comment">// races we can explicitly mark it as Send and Sync using unsafe</span><br><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span> <span class="hljs-built_in">Send</span> <span class="hljs-keyword">for</span> SomeType &#123;&#125;<br><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span> <span class="hljs-built_in">Sync</span> <span class="hljs-keyword">for</span> SomeType &#123;&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="二、Auto-Trait"><a href="#二、Auto-Trait" class="headerlink" title="二、Auto Trait"></a>二、Auto Trait</h2><h3 id="1-Send-amp-Sync"><a href="#1-Send-amp-Sync" class="headerlink" title="1. Send &amp; Sync"></a>1. Send &amp; Sync</h3><ol><li><p>如果一个类型满足Send，说明该类型可以安全地在线程中发送（或者说移动）</p></li><li><p>如果一个类型满足Sync，说明该类型可以安全地在线程中共享引用</p></li><li><p>In more precise terms some type T is Sync if and only if &amp;T is Send.</p><p> 当且仅当&amp;T类型满足Send Trait，T才满足Sync Trait</p></li><li><p>几乎所有的类型都满足Send、Sync</p><ol><li>Send Trait例外：Rc<ol><li>线程安全的版本：Arc</li></ol></li><li>Sync Trait例外：Rc、Cell、RefCell<ol><li>线程安全的Cell&#x2F;RefCell : Mutex&#x2F;RwLock</li></ol></li><li>可以使用Mutex&#x2F;Rwlock包装原始类型获得原子性，也可以使用标准库提供的：AtomBool之类的原子类型</li></ol></li><li><p>即使没有任何内部同步的类型，由于Rust借用规则的保证，这个类型大概率格式满足Sync的</p><ol><li>一个例子，多个线程只读共享&amp;str 类型的 greeting_ref，<ol><li><p>在不可变引用仍存在时，不允许出现可变引用。</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> crossbeam::thread;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> greeting = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    <span class="hljs-keyword">let</span> greeting_ref = &amp;greeting;<br>    <br>    thread::scope(|scoped_thread| &#123;<br>        <span class="hljs-comment">// spawn 3 threads</span><br>        <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..=<span class="hljs-number">3</span> &#123;<br>            <span class="hljs-comment">// greeting_ref copied into every thread</span><br>            scoped_thread.spawn(<span class="hljs-keyword">move</span> |_| &#123;<br>                <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, greeting_ref, n); <span class="hljs-comment">// prints &quot;Hello &#123;n&#125;&quot;</span><br>            &#125;);<br>        &#125;<br>        <br>        <span class="hljs-comment">// line below could cause UB or data races but compiler rejects it</span><br>        greeting += <span class="hljs-string">&quot; world&quot;</span>; <span class="hljs-comment">// ❌ cannot mutate greeting while immutable refs exist</span><br>    &#125;);<br>    <br>    <span class="hljs-comment">// can mutate greeting after every thread has joined</span><br>    greeting += <span class="hljs-string">&quot; world&quot;</span>; <span class="hljs-comment">// ✅</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, greeting); <span class="hljs-comment">// prints &quot;Hello world&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><p> b. 也可以一个线程可写</p><p> 在一个可变引用存在的时候，不允许出现第二个可变引用</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> crossbeam::thread;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> greeting = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    <span class="hljs-keyword">let</span> greeting_ref = &amp;<span class="hljs-keyword">mut</span> greeting;<br>    <br>    thread::scope(|scoped_thread| &#123;<br>        <span class="hljs-comment">// greeting_ref moved into thread</span><br>        scoped_thread.spawn(<span class="hljs-keyword">move</span> |_| &#123;<br>            *greeting_ref += <span class="hljs-string">&quot; world&quot;</span>;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, greeting_ref); <span class="hljs-comment">// prints &quot;Hello world&quot;</span><br>        &#125;);<br>        <br>        <span class="hljs-comment">// line below could cause UB or data races but compiler rejects it</span><br>        greeting += <span class="hljs-string">&quot;!!!&quot;</span>; <span class="hljs-comment">// ❌ cannot mutate greeting while mutable refs exist</span><br>    &#125;);<br>    <br>    <span class="hljs-comment">// can mutate greeting after the thread has joined</span><br>    greeting += <span class="hljs-string">&quot;!!!&quot;</span>; <span class="hljs-comment">// ✅</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, greeting); <span class="hljs-comment">// prints &quot;Hello world!!!&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-Sized"><a href="#2-Sized" class="headerlink" title="2. Sized"></a>2. Sized</h3><ol><li><p>如果一个类型是<code>Sized</code>，这意味着它的类型大小在编译期是可知的，并且可以在栈上创建一个该类型的实例。</p></li><li><p>所有的泛型隐含了Sized Trait约束</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">func</span></span>&lt;T&gt;(t: &amp;T) &#123;&#125;<br><br><span class="hljs-comment">// example above desugared</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">func</span></span>&lt;T: <span class="hljs-built_in">Sized</span>&gt;(t: &amp;T) &#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>因为所有的泛型类型上都有一个隐含的Sized约束，如果我们想要选择松弛这个约束，我们需要使用特定的“宽松约束（relaxed bound）”语法——?Sized，该语法目前只为Sized trait 存在。</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// now T can be unsized</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">func</span></span>&lt;T: ?<span class="hljs-built_in">Sized</span>&gt;(t: &amp;T) &#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>所有的Trait隐含了<code>?size</code> 的约束</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Trait</span></span> &#123;&#125;<br><br><span class="hljs-comment">// example above desugared</span><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Trait</span></span>: ?<span class="hljs-built_in">Sized</span> &#123;&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h2 id="三、General-Traits"><a href="#三、General-Traits" class="headerlink" title="三、General Traits"></a>三、General Traits</h2><h3 id="1-Default"><a href="#1-Default" class="headerlink" title="1. Default"></a>1. Default</h3><ol><li><p>可以为实现Default的类型构造默认值</p><ol><li>注意default函数没有self参数，因为其功能就是创造一个类型实例</li></ol> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Color</span></span> &#123;<br>    r: <span class="hljs-built_in">u8</span>,<br>    g: <span class="hljs-built_in">u8</span>,<br>    b: <span class="hljs-built_in">u8</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-built_in">Default</span> <span class="hljs-keyword">for</span> Color &#123;<br>    <span class="hljs-comment">// default color is black</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">default</span></span>() -&gt; <span class="hljs-keyword">Self</span> &#123;<br>        Color &#123;<br>            r: <span class="hljs-number">0</span>,<br>            g: <span class="hljs-number">0</span>,<br>            b: <span class="hljs-number">0</span>,<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 默认值构造</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-comment">// just give me some color!</span><br>    <span class="hljs-keyword">let</span> color = Color::default();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>default函数也可以用在泛型类型中</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">guarantee_length</span></span>&lt;T: <span class="hljs-built_in">Default</span>&gt;(<span class="hljs-keyword">mut</span> vec: <span class="hljs-built_in">Vec</span>&lt;T&gt;, min_len: <span class="hljs-built_in">usize</span>) -&gt; <span class="hljs-built_in">Vec</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..min_len.saturating_sub(vec.len()) &#123;<br>        vec.push(T::default());<br>    &#125;<br>    vec<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>也可以用派生宏的方式实现Default trait</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// default color is still black</span><br><span class="hljs-comment">// because u8::default() == 0</span><br><span class="hljs-meta">#[derive(Default)]</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Color</span></span> &#123;<br>    r: <span class="hljs-built_in">u8</span>,<br>    g: <span class="hljs-built_in">u8</span>,<br>    b: <span class="hljs-built_in">u8</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-Clone"><a href="#2-Clone" class="headerlink" title="2. Clone"></a>2. Clone</h3><p>预备知识</p><ol><li><p>Self指代实现的类型</p></li><li><p>Methods指对类型实例操作的函数</p></li><li><p><strong><strong>Default Impls 指Trait定义中可以包含函数&#x2F;方法的默认实现</strong></strong></p></li><li><p><strong><strong>Derive Macros 派生宏 指的是类型定义的时候可以通过派生宏的方式实现一个Trait</strong></strong></p></li><li><p>Clone trait中包含两个函数</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Clone</span></span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">clone</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-keyword">Self</span>;<br><br>    <span class="hljs-comment">// provided default impls</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">clone_from</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, source: &amp;<span class="hljs-keyword">Self</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Clone Trait的作用是，从一个不可变引用，转换为所拥有的值。即&amp;T-&gt;T。</p><ol><li>Clone不保证这种转换的效率，所以它会很慢并且成本较高。</li></ol></li><li><p>可以通过派生宏快速实现Clone Trait</p><ol><li>下面的例子中两种实现是等价的</li></ol> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Clone)]</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SomeType</span></span> &#123;<br>    cloneable_member1: CloneableType1,<br>    cloneable_member2: CloneableType2,<br>    <span class="hljs-comment">// etc</span><br>&#125;<br><br><span class="hljs-comment">// macro generates impl below</span><br><span class="hljs-keyword">impl</span> <span class="hljs-built_in">Clone</span> <span class="hljs-keyword">for</span> SomeType &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">clone</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-keyword">Self</span> &#123;<br>        SomeType &#123;<br>            cloneable_member1: <span class="hljs-keyword">self</span>.cloneable_member1.clone(),<br>            cloneable_member2: <span class="hljs-keyword">self</span>.cloneable_member2.clone(),<br>            <span class="hljs-comment">// etc</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-Copy"><a href="#3-Copy" class="headerlink" title="3. Copy"></a>3. Copy</h3><p>预备知识</p><ol><li><p>标记Trait</p></li><li><p>子集和超集</p></li><li><p>派生宏</p></li><li><p>Copy Trait</p><ol><li><p>定义</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Copy</span></span>: <span class="hljs-built_in">Clone</span> &#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>作用</p><p> 按位拷贝，即T -&gt; T</p></li><li><p>实现</p><p> 只能通过派生宏实现，下面的两个实现是等价的</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Copy, Clone)]</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SomeType</span></span>;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>Copy是Clone的子集：如果一个类型实现了Copy，那么这个类型自然满足Clone</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// this is what the derive macro generates</span><br><span class="hljs-keyword">impl</span>&lt;T: <span class="hljs-built_in">Copy</span>&gt; <span class="hljs-built_in">Clone</span> <span class="hljs-keyword">for</span> T &#123;<br>    <span class="hljs-comment">// the clone method becomes just a copy</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">clone</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-keyword">Self</span> &#123;<br>        *<span class="hljs-keyword">self</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>一个类型如果实现了Copy，它在被移动（move）时的行为就发生了改变。默认情况下，所有的类型都有移动（move）语义 ，但是一旦某个类型实现了Copy，它就有了拷贝（copy）语义 。</p><ol><li><p>一个例子，第一种情况下发生“移动”：src在移动后不可用。第二种情况发生“拷贝”：src在拷贝后仍有效</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// a &quot;move&quot;, src: !Copy</span><br><span class="hljs-keyword">let</span> dest = src;<br><br><span class="hljs-comment">// a &quot;copy&quot;, src: Copy</span><br><span class="hljs-keyword">let</span> dest = src;<br></code></pre></td></tr></table></figure></li><li><p>Vec&lt;&gt; 类型只能移动，不能拷贝</p><ol><li><p>Vec<i32>类型如下</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">&#123; data: *<span class="hljs-keyword">mut</span> [<span class="hljs-built_in">i32</span>], length: <span class="hljs-built_in">usize</span>, capacity: <span class="hljs-built_in">usize</span> &#125;<br></code></pre></td></tr></table></figure></li><li><p>如果允许Copy的话</p><p> src和dest就都有了数据的可变引用，这不满足Rust借用器检查</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">src = &#123; data: *<span class="hljs-keyword">mut</span> [<span class="hljs-built_in">i32</span>], length: <span class="hljs-built_in">usize</span>, capacity: <span class="hljs-built_in">usize</span> &#125;<br>dest = &#123; data: *<span class="hljs-keyword">mut</span> [<span class="hljs-built_in">i32</span>], length: <span class="hljs-built_in">usize</span>, capacity: <span class="hljs-built_in">usize</span> &#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>Option&lt;&gt;类型也可以实现拷贝</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">&#123; is_valid: <span class="hljs-built_in">bool</span>, data: <span class="hljs-built_in">i32</span> &#125;<br></code></pre></td></tr></table></figure><p> 拷贝后</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">src = &#123; is_valid: <span class="hljs-built_in">bool</span>, data: <span class="hljs-built_in">i32</span> &#125;<br>dest = &#123; is_valid: <span class="hljs-built_in">bool</span>, data: <span class="hljs-built_in">i32</span> &#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>需要注意：Copy trait需要程序员显式地实现。</p></li></ol><h3 id="4-Any"><a href="#4-Any" class="headerlink" title="4. Any"></a>4. Any</h3><ol><li><p>预备知识</p><ol><li><strong>泛型覆盖实现，Trait定义的函数中，参数重满足一些Trait的类型，提供默认实现</strong></li></ol></li><li><p>Any Trait作用：实现“多态”的需求</p><ol><li>一个例子，从dyn Any类型中取出类型T需要使用<code>downcast_ref::&lt;T&gt;()</code> 和 <code>downcast_mut::&lt;T&gt;()</code> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::any::Any;<br><br><span class="hljs-meta">#[derive(Default)]</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span></span> &#123;<br>    x: <span class="hljs-built_in">i32</span>,<br>    y: <span class="hljs-built_in">i32</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> Point &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">inc</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">self</span>.x += <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">self</span>.y += <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">map_any</span></span>(<span class="hljs-keyword">mut</span> any: <span class="hljs-built_in">Box</span>&lt;<span class="hljs-keyword">dyn</span> Any&gt;) -&gt; <span class="hljs-built_in">Box</span>&lt;<span class="hljs-keyword">dyn</span> Any&gt; &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(num) = any.downcast_mut::&lt;<span class="hljs-built_in">i32</span>&gt;() &#123;<br>        *num += <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(string) = any.downcast_mut::&lt;<span class="hljs-built_in">String</span>&gt;() &#123;<br>        *string += <span class="hljs-string">&quot;!&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(point) = any.downcast_mut::&lt;Point&gt;() &#123;<br>        point.inc();<br>    &#125;<br>    any<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> vec: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">Box</span>&lt;<span class="hljs-keyword">dyn</span> Any&gt;&gt; = <span class="hljs-built_in">vec!</span>[<br>        <span class="hljs-built_in">Box</span>::new(<span class="hljs-number">0</span>),<br>        <span class="hljs-built_in">Box</span>::new(<span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;a&quot;</span>)),<br>        <span class="hljs-built_in">Box</span>::new(Point::default()),<br>    ];<br>    <span class="hljs-comment">// vec = [0, &quot;a&quot;, Point &#123; x: 0, y: 0 &#125;]</span><br>    vec = vec.into_iter().map(map_any).collect();<br>    <span class="hljs-comment">// vec = [1, &quot;a!&quot;, Point &#123; x: 1, y: 1 &#125;]</span><br>&#125;<br></code></pre></td></tr></table></figure> 但也可以通过参数化多态来实现多态 在大多数情况下，参数化多态要优于临时多态性，后者也可以用枚举（enum）来模拟，枚举具有更好的类型安全，需要的间接（抽象）也更少。 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Default)]</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span></span> &#123;<br>    x: <span class="hljs-built_in">i32</span>,<br>    y: <span class="hljs-built_in">i32</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> Point &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">inc</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">self</span>.x += <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">self</span>.y += <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Stuff</span></span> &#123;<br>    Integer(<span class="hljs-built_in">i32</span>),<br>    <span class="hljs-built_in">String</span>(<span class="hljs-built_in">String</span>),<br>    Point(Point),<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">map_stuff</span></span>(<span class="hljs-keyword">mut</span> stuff: Stuff) -&gt; Stuff &#123;<br>    <span class="hljs-keyword">match</span> &amp;<span class="hljs-keyword">mut</span> stuff &#123;<br>        Stuff::Integer(num) =&gt; *num += <span class="hljs-number">1</span>,<br>        Stuff::<span class="hljs-built_in">String</span>(string) =&gt; *string += <span class="hljs-string">&quot;!&quot;</span>,<br>        Stuff::Point(point) =&gt; point.inc(),<br>    &#125;<br>    stuff<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> vec = <span class="hljs-built_in">vec!</span>[<br>        Stuff::Integer(<span class="hljs-number">0</span>),<br>        Stuff::<span class="hljs-built_in">String</span>(<span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;a&quot;</span>)),<br>        Stuff::Point(Point::default()),<br>    ];<br>    <span class="hljs-comment">// vec = [0, &quot;a&quot;, Point &#123; x: 0, y: 0 &#125;]</span><br>    vec = vec.into_iter().map(map_stuff).collect();<br>    <span class="hljs-comment">// vec = [1, &quot;a!&quot;, Point &#123; x: 1, y: 1 &#125;]</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>Any Trait的实现</p><p> 不需要手动实现，均被“<strong>泛型覆盖实现</strong>”所覆盖</p><p> Any trait中仅包含一个type_id函数，标准库的默认实现已经覆盖了所有类型</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// https://doc.rust-lang.org/std/any/trait.Any.html</span><br><span class="hljs-meta">#[stable(feature = <span class="hljs-meta-string">&quot;rust1&quot;</span>, since = <span class="hljs-meta-string">&quot;1.0.0&quot;</span>)]</span><br><span class="hljs-meta">#[cfg_attr(not(test), rustc_diagnostic_item = <span class="hljs-meta-string">&quot;Any&quot;</span>)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Any</span></span>: <span class="hljs-symbol">&#x27;static</span> &#123;<br>    <span class="hljs-comment">/// Gets the `TypeId` of `self`.</span><br>    <span class="hljs-comment">///</span><br>    <span class="hljs-comment">/// # Examples</span><br>    <span class="hljs-comment">///</span><br>    <span class="hljs-comment">/// ```</span><br>    <span class="hljs-comment">/// use std::any::&#123;Any, TypeId&#125;;</span><br>    <span class="hljs-comment">///</span><br>    <span class="hljs-comment">/// fn is_string(s: &amp;dyn Any) -&gt; bool &#123;</span><br>    <span class="hljs-comment">///     TypeId::of::&lt;String&gt;() == s.type_id()</span><br>    <span class="hljs-comment">/// &#125;</span><br>    <span class="hljs-comment">///</span><br>    <span class="hljs-comment">/// assert_eq!(is_string(&amp;0), false);</span><br>    <span class="hljs-comment">/// assert_eq!(is_string(&amp;&quot;cookie monster&quot;.to_string()), true);</span><br>    <span class="hljs-comment">/// ```</span><br>    <span class="hljs-meta">#[stable(feature = <span class="hljs-meta-string">&quot;get_type_id&quot;</span>, since = <span class="hljs-meta-string">&quot;1.34.0&quot;</span>)]</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">type_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; TypeId;<br>&#125;<br><br><span class="hljs-meta">#[stable(feature = <span class="hljs-meta-string">&quot;rust1&quot;</span>, since = <span class="hljs-meta-string">&quot;1.0.0&quot;</span>)]</span><br><span class="hljs-keyword">impl</span>&lt;T: <span class="hljs-symbol">&#x27;static</span> + ?<span class="hljs-built_in">Sized</span>&gt; Any <span class="hljs-keyword">for</span> T &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">type_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; TypeId &#123;<br>        TypeId::of::&lt;T&gt;()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="四、Formatting-Trait"><a href="#四、Formatting-Trait" class="headerlink" title="四、Formatting Trait"></a>四、Formatting Trait</h2><table><thead><tr><th>Trait</th><th>Placeholder</th><th>Description</th></tr></thead><tbody><tr><td>Display</td><td>{}</td><td>display representation</td></tr><tr><td>Debug</td><td>{:?}</td><td>debug representation</td></tr><tr><td>Octal</td><td>{:o}</td><td>octal representation</td></tr><tr><td>LowerHex</td><td>{:x}</td><td>lowercase hex representation</td></tr><tr><td>UpperHex</td><td>{:X}</td><td>uppercase hex representation</td></tr><tr><td>Pointer</td><td>{:p}</td><td>memory address</td></tr><tr><td>Binary</td><td>{:b}</td><td>binary representation</td></tr><tr><td>LowerExp</td><td>{:e}</td><td>lowercase exponential representation</td></tr><tr><td>UpperExp</td><td>{:E}</td><td>uppercase exponential representation</td></tr></tbody></table><h3 id="1-Display-Trait-amp-ToString-Trait"><a href="#1-Display-Trait-amp-ToString-Trait" class="headerlink" title="1. Display Trait &amp; ToString Trait"></a>1. Display Trait &amp; ToString Trait</h3><ol><li><p>Display trait</p><ol><li><p>定义</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Display</span></span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">fmt</span></span>(&amp;<span class="hljs-keyword">self</span>, f: &amp;<span class="hljs-keyword">mut</span> Formatter&lt;<span class="hljs-symbol">&#x27;_</span>&gt;) -&gt; <span class="hljs-built_in">Result</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>作用：用户定义的类型想格式化打印的时候可以实现Display trait</p><p> 比如给Point 类型实现Display trait，实现后类型的实例就可以在格式化输出中输出为字符串</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt;<br><br><span class="hljs-meta">#[derive(Default)]</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span></span> &#123;<br>    x: <span class="hljs-built_in">i32</span>,<br>    y: <span class="hljs-built_in">i32</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> fmt::Display <span class="hljs-keyword">for</span> Point &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">fmt</span></span>(&amp;<span class="hljs-keyword">self</span>, f: &amp;<span class="hljs-keyword">mut</span> fmt::Formatter&lt;<span class="hljs-symbol">&#x27;_</span>&gt;) -&gt; fmt::<span class="hljs-built_in">Result</span> &#123;<br>        <span class="hljs-built_in">write!</span>(f, <span class="hljs-string">&quot;(&#123;&#125;, &#123;&#125;)&quot;</span>, <span class="hljs-keyword">self</span>.x, <span class="hljs-keyword">self</span>.y)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;origin: &#123;&#125;&quot;</span>, Point::default());<br>    <span class="hljs-comment">// prints &quot;origin: (0, 0)&quot;</span><br><br>    <span class="hljs-comment">// get Point&#x27;s Display representation as a String</span><br>    <span class="hljs-keyword">let</span> stringified_point = <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, Point::default());<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-string">&quot;(0, 0)&quot;</span>, stringified_point); <span class="hljs-comment">// ✅</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>ToString </p><ol><li><p>定义</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">ToString</span></span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">to_string</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">String</span>;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T: Display + ?<span class="hljs-built_in">Sized</span>&gt; <span class="hljs-built_in">ToString</span> <span class="hljs-keyword">for</span> T;<br></code></pre></td></tr></table></figure></li><li><p>所有实现Display Trait的类型都自动实现Tostring Trait（Again，泛型覆盖实现）</p></li><li><p>可以调用to_string 方法将对象转换为格式化打印</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[test]</span> <span class="hljs-comment">// ✅</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">display_point</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> origin = Point::default();<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, origin), <span class="hljs-string">&quot;(0, 0)&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">#[test]</span> <span class="hljs-comment">// ✅</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">point_to_string</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> origin = Point::default();<br>    <span class="hljs-built_in">assert_eq!</span>(origin.to_string(), <span class="hljs-string">&quot;(0, 0)&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">#[test]</span> <span class="hljs-comment">// ✅</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">display_equals_to_string</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> origin = Point::default();<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, origin), origin.to_string());<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h3 id="2-Debug"><a href="#2-Debug" class="headerlink" title="2. Debug"></a>2. Debug</h3><ol><li><p>定义</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Debug</span></span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">fmt</span></span>(&amp;<span class="hljs-keyword">self</span>, f: &amp;<span class="hljs-keyword">mut</span> Formatter&lt;<span class="hljs-symbol">&#x27;_</span>&gt;) -&gt; <span class="hljs-built_in">Result</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>实现Debug Trait：可以通过派生宏，也可以自己定义输出</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><br><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span></span> &#123;<br>    x: <span class="hljs-built_in">i32</span>,<br>    y: <span class="hljs-built_in">i32</span>,<br>&#125;<br><br><span class="hljs-comment">// derive macro generates impl below</span><br><span class="hljs-keyword">impl</span> fmt::<span class="hljs-built_in">Debug</span> <span class="hljs-keyword">for</span> Point &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">fmt</span></span>(&amp;<span class="hljs-keyword">self</span>, f: &amp;<span class="hljs-keyword">mut</span> fmt::Formatter&lt;<span class="hljs-symbol">&#x27;_</span>&gt;) -&gt; fmt::<span class="hljs-built_in">Result</span> &#123;<br>        f.debug_struct(<span class="hljs-string">&quot;Point&quot;</span>)<br>            .field(<span class="hljs-string">&quot;x&quot;</span>, &amp;<span class="hljs-keyword">self</span>.x)<br>            .field(<span class="hljs-string">&quot;y&quot;</span>, &amp;<span class="hljs-keyword">self</span>.y)<br>            .finish()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>dbg! 输出和 print! 输出的区别</p><ul><li>dbg!打印到 stderr 而不是 stdout，因此在我们的程序中，能够很容易地和标准输出的输出结果区分。</li><li>dbg!会连同传入的表达式和表达式的计算结果一起打印出来。</li><li>dbg!会获取传入参数的所有权并将其返回，因此你可以在表达式中使用它：</li></ul></li></ol><h2 id="五、Opertor-Traits"><a href="#五、Opertor-Traits" class="headerlink" title="五、Opertor Traits"></a>五、Opertor Traits</h2><p>Rust中所有操作符均有一个Trait与之对应</p><table><thead><tr><th>Trait(s)</th><th>Category</th><th>Operator(s)</th><th>Description</th></tr></thead><tbody><tr><td>Eq, PartialEq</td><td>comparison</td><td>&#x3D;&#x3D;</td><td>equality</td></tr><tr><td>Ord, PartialOrd</td><td>comparison</td><td>&lt;, &gt;, &lt;&#x3D;, &gt;&#x3D;</td><td>comparison</td></tr><tr><td>Add</td><td>arithmetic</td><td>+</td><td>addition</td></tr><tr><td>AddAssign</td><td>arithmetic</td><td>+&#x3D;</td><td>addition assignment</td></tr><tr><td>BitAnd</td><td>arithmetic</td><td>&amp;</td><td>bitwise AND</td></tr><tr><td>BitAndAssign</td><td>arithmetic</td><td>&amp;&#x3D;</td><td>bitwise assignment</td></tr><tr><td>BitXor</td><td>arithmetic</td><td>^</td><td>bitwise XOR</td></tr><tr><td>BitXorAssign</td><td>arithmetic</td><td>^&#x3D;</td><td>bitwise XOR assignment</td></tr><tr><td>Div</td><td>arithmetic</td><td>&#x2F;</td><td>division</td></tr><tr><td>DivAssign</td><td>arithmetic</td><td>&#x2F;&#x3D;</td><td>division assignment</td></tr><tr><td>Mul</td><td>arithmetic</td><td>*</td><td>multiplication</td></tr><tr><td>MulAssign</td><td>arithmetic</td><td>*&#x3D;</td><td>multiplication assignment</td></tr><tr><td>Neg</td><td>arithmetic</td><td>-</td><td>unary negation</td></tr><tr><td>Not</td><td>arithmetic</td><td>!</td><td>unary logical negation</td></tr><tr><td>Rem</td><td>arithmetic</td><td>%</td><td>remainder</td></tr><tr><td>RemAssign</td><td>arithmetic</td><td>%&#x3D;</td><td>remainder assignment</td></tr><tr><td>Shl</td><td>arithmetic</td><td>&lt;&lt;</td><td>left shift</td></tr><tr><td>ShlAssign</td><td>arithmetic</td><td>&lt;&lt;&#x3D;</td><td>left shift assignment</td></tr><tr><td>Shr</td><td>arithmetic</td><td>&gt;&gt;</td><td>right shift</td></tr><tr><td>ShrAssign</td><td>arithmetic</td><td>&gt;&gt;&#x3D;</td><td>right shift assignment</td></tr><tr><td>Sub</td><td>arithmetic</td><td>-</td><td>subtraction</td></tr><tr><td>SubAssign</td><td>arithmetic</td><td>-&#x3D;</td><td>subtraction assignment</td></tr><tr><td>Fn</td><td>closure</td><td>(…args)</td><td>immutable closure invocation</td></tr><tr><td>FnMut</td><td>closure</td><td>(…args)</td><td>mutable closure invocation</td></tr><tr><td>FnOnce</td><td>closure</td><td>(…args)</td><td>one-time closure invocation</td></tr><tr><td>Deref</td><td>other</td><td>*</td><td>immutable dereference</td></tr><tr><td>DerefMut</td><td>other</td><td>*</td><td>mutable derenence</td></tr><tr><td>Drop</td><td>other</td><td>-</td><td>type destructor</td></tr><tr><td>Index</td><td>other</td><td>[]</td><td>immutable index</td></tr><tr><td>IndexMut</td><td>other</td><td>[]</td><td>mutable index</td></tr><tr><td>RangeBounds</td><td>other</td><td>..</td><td>range</td></tr></tbody></table><p>下面逐个介绍</p><h3 id="1-Comparison-Traits"><a href="#1-Comparison-Traits" class="headerlink" title="1. Comparison Traits"></a>1. <strong><strong>Comparison Traits</strong></strong></h3><table><thead><tr><th>Trait(s)</th><th>Category</th><th>Operator(s)</th><th>Description</th></tr></thead><tbody><tr><td>Eq, PartialEq</td><td>comparison</td><td>&#x3D;&#x3D;</td><td>equality</td></tr><tr><td>Ord, PartialOrd</td><td>comparison</td><td>&lt;, &gt;, &lt;&#x3D;, &gt;&#x3D;</td><td>comparison</td></tr></tbody></table><ol><li><p>PartialEq Trait</p><ol><li><p>定义</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">PartialEq</span></span>&lt;Rhs = <span class="hljs-keyword">Self</span>&gt; <br><span class="hljs-keyword">where</span><br>    Rhs: ?<span class="hljs-built_in">Sized</span>, <br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">eq</span></span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;Rhs) -&gt; <span class="hljs-built_in">bool</span>;<br><br>    <span class="hljs-comment">// provided default impls</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">ne</span></span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;Rhs) -&gt; <span class="hljs-built_in">bool</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>作用</p><p> 满足PartialEq<Rhs>类型的实例可以通过&#x3D;&#x3D;操作符检查是否和Rhs类型的实例相等。</p></li><li><p>特点</p><ol><li>PartialEq表示的是集合论中的：对称性、传递性<ul><li>a &#x3D;&#x3D; b也意味着b &#x3D;&#x3D; a（对称性）</li><li>a &#x3D;&#x3D; b &amp;&amp; b &#x3D;&#x3D; c 意味着 a &#x3D;&#x3D; c （传递性）</li></ul></li></ol></li><li><p>实现</p><ol><li>如果一个类型中所有成员均实现了PartialEq，那么这个类型的PartialEq Trait可以被派生宏实现</li></ol></li><li><p>引用类型的实现</p><ol><li><p>again，由于”泛型覆盖实现”的特性，一旦一个类型满足了PartialEq trait，那么对应的引用类型的比较也自然被实现了，换句话说，该类型的引用类型也可以被比较了。</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// this impl only gives us: Point == Point</span><br><span class="hljs-meta">#[derive(PartialEq)]</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span></span> &#123;<br>    x: <span class="hljs-built_in">i32</span>,<br>    y: <span class="hljs-built_in">i32</span><br>&#125;<br><br><span class="hljs-comment">// all of the generic blanket impls below</span><br><span class="hljs-comment">// are provided by the standard library</span><br><br><span class="hljs-comment">// this impl gives us: &amp;Point == &amp;Point</span><br><span class="hljs-keyword">impl</span>&lt;A, B&gt; <span class="hljs-built_in">PartialEq</span>&lt;&amp;<span class="hljs-symbol">&#x27;_</span> B&gt; <span class="hljs-keyword">for</span> &amp;<span class="hljs-symbol">&#x27;_</span> A<br><span class="hljs-keyword">where</span> A: <span class="hljs-built_in">PartialEq</span>&lt;B&gt; + ?<span class="hljs-built_in">Sized</span>, B: ?<span class="hljs-built_in">Sized</span>;<br><br><span class="hljs-comment">// this impl gives us: &amp;mut Point == &amp;Point</span><br><span class="hljs-keyword">impl</span>&lt;A, B&gt; <span class="hljs-built_in">PartialEq</span>&lt;&amp;<span class="hljs-symbol">&#x27;_</span> B&gt; <span class="hljs-keyword">for</span> &amp;<span class="hljs-symbol">&#x27;_</span> <span class="hljs-keyword">mut</span> A<br><span class="hljs-keyword">where</span> A: <span class="hljs-built_in">PartialEq</span>&lt;B&gt; + ?<span class="hljs-built_in">Sized</span>, B: ?<span class="hljs-built_in">Sized</span>;<br><br><span class="hljs-comment">// this impl gives us: &amp;Point == &amp;mut Point</span><br><span class="hljs-keyword">impl</span>&lt;A, B&gt; <span class="hljs-built_in">PartialEq</span>&lt;&amp;<span class="hljs-symbol">&#x27;_</span> <span class="hljs-keyword">mut</span> B&gt; <span class="hljs-keyword">for</span> &amp;<span class="hljs-symbol">&#x27;_</span> A<br><span class="hljs-keyword">where</span> A: <span class="hljs-built_in">PartialEq</span>&lt;B&gt; + ?<span class="hljs-built_in">Sized</span>, B: ?<span class="hljs-built_in">Sized</span>;<br><br><span class="hljs-comment">// this impl gives us: &amp;mut Point == &amp;mut Point</span><br><span class="hljs-keyword">impl</span>&lt;A, B&gt; <span class="hljs-built_in">PartialEq</span>&lt;&amp;<span class="hljs-symbol">&#x27;_</span> <span class="hljs-keyword">mut</span> B&gt; <span class="hljs-keyword">for</span> &amp;<span class="hljs-symbol">&#x27;_</span> <span class="hljs-keyword">mut</span> A<br><span class="hljs-keyword">where</span> A: <span class="hljs-built_in">PartialEq</span>&lt;B&gt; + ?<span class="hljs-built_in">Sized</span>, B: ?<span class="hljs-built_in">Sized</span>;<br></code></pre></td></tr></table></figure></li></ol><p> ii. 因为这个 trait 是泛型的，所以我们可以在不同的类型之间定义相等性（比较）。标准库利用这一点实现了类字符串类型之间的相互比较，比如String、&amp;str、PathBuf、&amp;Path、OsString、&amp;OsStr等等。</p></li></ol></li><li><p>Eq Trait</p><ol><li><p>定义</p><p> 是一个标记Trait，是PartialEq的子集</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Eq</span></span>: <span class="hljs-built_in">PartialEq</span>&lt;<span class="hljs-keyword">Self</span>&gt; &#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>作用</p><p> 在PartialEq基础上要求“自反性”。也就是对于任意的a，都有a &#x3D;&#x3D; a。</p><p> 从这种意义上来说，Eq对PartialEq进行了细化，因为它表示了一个更为严格的相等性。</p></li><li><p>实现</p><p> 如果一个类型的所有成员都实现了Eq，那么Eq的实现可以派生到这个类型。</p><p> 浮点型实现了PartialEq但是没有实现Eq，因为NaN !&#x3D; NaN。几乎所有其他的实现了PartialEq的类型都实现了Eq，除非它们包含浮点类型。</p></li><li><p>备注：一旦一个类型实现了PartialEq和Debug，我们可以就可以在assert_eq!宏中使用它。</p><ol><li><p>还可以比较实现了PartialEq类型的集合。下面是一个例子</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(PartialEq, Debug)]</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span></span> &#123;<br>    x: <span class="hljs-built_in">i32</span>,<br>    y: <span class="hljs-built_in">i32</span>,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">example_assert</span></span>(p1: Point, p2: Point) &#123;<br>    <span class="hljs-built_in">assert_eq!</span>(p1, p2);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">example_compare_collections</span></span>&lt;T: <span class="hljs-built_in">PartialEq</span>&gt;(vec1: <span class="hljs-built_in">Vec</span>&lt;T&gt;, vec2: <span class="hljs-built_in">Vec</span>&lt;T&gt;) &#123;<br>    <span class="hljs-comment">// if T: PartialEq this now works!</span><br>    <span class="hljs-keyword">if</span> vec1 == vec2 &#123;<br>        <span class="hljs-comment">// some code</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// other code</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol></li></ol><h3 id="2-Hash-Trait"><a href="#2-Hash-Trait" class="headerlink" title="2. Hash Trait"></a>2. Hash Trait</h3><ol><li><p>定义</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Hash</span></span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">hash</span></span>&lt;H: Hasher&gt;(&amp;<span class="hljs-keyword">self</span>, state: &amp;<span class="hljs-keyword">mut</span> H);<br><br>    <span class="hljs-comment">// provided default impls</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">hash_slice</span></span>&lt;H: Hasher&gt;(data: &amp;[<span class="hljs-keyword">Self</span>], state: &amp;<span class="hljs-keyword">mut</span> H);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>作用</p><p> 满足Hash Trait的类型可以被满足Hasher trait的的对象计算哈希值</p><p> 也就可以放在HashMap HashSet 的Key中</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::hash::Hasher;<br><span class="hljs-keyword">use</span> std::hash::Hash;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span></span> &#123;<br>    x: <span class="hljs-built_in">i32</span>,<br>    y: <span class="hljs-built_in">i32</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> Hash <span class="hljs-keyword">for</span> Point &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">hash</span></span>&lt;H: Hasher&gt;(&amp;<span class="hljs-keyword">self</span>, hasher: &amp;<span class="hljs-keyword">mut</span> H) &#123;<br>        hasher.write_i32(<span class="hljs-keyword">self</span>.x);<br>        hasher.write_i32(<span class="hljs-keyword">self</span>.y);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>实现</p><p> 可以通过派生宏实现</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Hash)]</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span></span> &#123;<br>    x: <span class="hljs-built_in">i32</span>,<br>    y: <span class="hljs-built_in">i32</span>,<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>特点</p><ol><li>如果a &#x3D;&#x3D; b那么a.hash() &#x3D;&#x3D; b.hash()</li><li>如果一个类型的Eq Trait是派生宏实现的，Hash Trait也需要是被派生宏实现；或者二者可以均被手动实现。<ol><li>但不要混合，因为可能会破坏“如果a &#x3D;&#x3D; b那么a.hash() &#x3D;&#x3D; b.hash()” 的保证</li></ol></li></ol></li></ol><h3 id="3-PartialOrd"><a href="#3-PartialOrd" class="headerlink" title="3. PartialOrd"></a>3. <strong><strong>PartialOrd</strong></strong></h3><ol><li><p>定义</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Ordering</span></span> &#123;<br>    Less,<br>    Equal,<br>    Greater,<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">PartialOrd</span></span>&lt;Rhs = <span class="hljs-keyword">Self</span>&gt;: <span class="hljs-built_in">PartialEq</span>&lt;Rhs&gt; <br><span class="hljs-keyword">where</span><br>    Rhs: ?<span class="hljs-built_in">Sized</span>, <br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">partial_cmp</span></span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;Rhs) -&gt; <span class="hljs-built_in">Option</span>&lt;Ordering&gt;;<br><br>    <span class="hljs-comment">// provided default impls</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">lt</span></span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;Rhs) -&gt; <span class="hljs-built_in">bool</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">le</span></span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;Rhs) -&gt; <span class="hljs-built_in">bool</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">gt</span></span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;Rhs) -&gt; <span class="hljs-built_in">bool</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">ge</span></span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;Rhs) -&gt; <span class="hljs-built_in">bool</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>作用</p><p> 满足PartialOrd<Rhs> Trait的类型可以通过 &lt;&#x2F; ≤&#x2F; &gt;&#x2F; ≥ 比较运算符和Rhs类型的实例比较大小</p></li><li><p>实现</p><ol><li><p>如果一个类型的所有成员都实现了PartialOrd，那么它就可以被派生实现</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(PartialEq, PartialOrd)]</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span></span> &#123;<br>    x: <span class="hljs-built_in">i32</span>,<br>    y: <span class="hljs-built_in">i32</span>,<br>&#125;<br><br><span class="hljs-meta">#[derive(PartialEq, PartialOrd)]</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Stoplight</span></span> &#123;<br>    Red,<br>    Yellow,<br>    Green,<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>特点</p><ol><li><p>PartialOrd表示的是集合论的偏序</p><p><a href="https://zh.wikipedia.org/zh-cn/%E5%81%8F%E5%BA%8F%E5%85%B3%E7%B3%BB">https://zh.wikipedia.org/zh-cn/偏序关系</a></p><p>集合中上的一个关系，这个关系对于集合中的部分元素具有反对称性+传递性，那么这个关系在这个集合上就是偏序（PartialOrder，局部序）的</p><ol><li>a &lt; b implies !(a &gt; b) (asymmetry) 反对称性</li><li>a &lt; b &amp;&amp; b &lt; c implies a &lt; c (transitivity) 传递性</li></ol></li><li><p>PartialOrder Trait是PartialEq Trait的子集</p><ol><li><p>二者的实现必须等价</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">must_always_agree</span></span>&lt;T: <span class="hljs-built_in">PartialOrd</span> + <span class="hljs-built_in">PartialEq</span>&gt;(t1: T, t2: T) &#123;<br>    <span class="hljs-built_in">assert_eq!</span>(t1.partial_cmp(&amp;t2) == <span class="hljs-literal">Some</span>(Ordering::Equal), t1 == t2);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>PartialOrder Trait 是在PartialEq Trait上的“特例化&#x2F;细化”</p><p> 满足PartialEq的类型只能比较相等&#x2F;不等；满足PartialOrder的类型也可以比较相等&#x2F;不相等，但是不等中还可以得出大于&#x2F;小于的结论</p></li></ol></li><li><p>派生宏实现的PartialOrder Trait，基于类型中成员变量的先后顺序比较的</p><p> 下面是个例子，前者先比较x，后者先比较y</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// generates PartialOrd impl which orders</span><br><span class="hljs-comment">// Points based on x member first and</span><br><span class="hljs-comment">// y member second because that&#x27;s the order</span><br><span class="hljs-comment">// they appear in the source code</span><br><span class="hljs-meta">#[derive(PartialOrd, PartialEq)]</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span></span> &#123;<br>    x: <span class="hljs-built_in">i32</span>,<br>    y: <span class="hljs-built_in">i32</span>,<br>&#125;<br><br><span class="hljs-comment">// generates DIFFERENT PartialOrd impl</span><br><span class="hljs-comment">// which orders Points based on y member</span><br><span class="hljs-comment">// first and x member second</span><br><span class="hljs-meta">#[derive(PartialOrd, PartialEq)]</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span></span> &#123;<br>    y: <span class="hljs-built_in">i32</span>,<br>    x: <span class="hljs-built_in">i32</span>,<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h3 id="4-Ord"><a href="#4-Ord" class="headerlink" title="4. Ord"></a>4. Ord</h3><ol><li><p>定义</p><p> Ord Trait是Eq Trait和PartialOrder Trait的子集</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Ord</span></span>: <span class="hljs-built_in">Eq</span> + <span class="hljs-built_in">PartialOrd</span>&lt;<span class="hljs-keyword">Self</span>&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">cmp</span></span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;<span class="hljs-keyword">Self</span>) -&gt; Ordering;<br><br>    <span class="hljs-comment">// provided default impls</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">max</span></span>(<span class="hljs-keyword">self</span>, other: <span class="hljs-keyword">Self</span>) -&gt; <span class="hljs-keyword">Self</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">min</span></span>(<span class="hljs-keyword">self</span>, other: <span class="hljs-keyword">Self</span>) -&gt; <span class="hljs-keyword">Self</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">clamp</span></span>(<span class="hljs-keyword">self</span>, min: <span class="hljs-keyword">Self</span>, max: <span class="hljs-keyword">Self</span>) -&gt; <span class="hljs-keyword">Self</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>作用</p><ol><li>比较大小、在两个实例中找最大、最小</li><li>一旦一个类型实现了Ord，我们就可以把它存储在BTreeMap和BTreeSet，还可以在 slice 上使用 sort()方法对其进行排序，这同样适用于其他可以解引用为 slice 的类型，比如数组、Vec和VecDeque。</li></ol></li><li><p>实现</p><ol><li><p>通过派生宏&#x2F;手动实现</p><p> 这里注意，Ord Trait是PartialOrderTrait的子集，实现了Ord Trait后，PartialOrder的实现可以使用Ord Trait中的实现。</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::cmp::Ordering;<br><br><span class="hljs-comment">// of course we can use the derive macros here</span><br><span class="hljs-meta">#[derive(Ord, PartialOrd, Eq, PartialEq)]</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span></span> &#123;<br>    x: <span class="hljs-built_in">i32</span>,<br>    y: <span class="hljs-built_in">i32</span>,<br>&#125;<br><br><span class="hljs-comment">// note: as with PartialOrd, the Ord derive macro</span><br><span class="hljs-comment">// orders a type based on the lexicographical order</span><br><span class="hljs-comment">// of its members</span><br><br><span class="hljs-comment">// but here&#x27;s the impls if we wrote them out by hand</span><br><span class="hljs-keyword">impl</span> <span class="hljs-built_in">Ord</span> <span class="hljs-keyword">for</span> Point &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">cmp</span></span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;<span class="hljs-keyword">Self</span>) -&gt; Ordering &#123;<br>        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.x.cmp(&amp;other.x) &#123;<br>            Ordering::Equal =&gt; <span class="hljs-keyword">self</span>.y.cmp(&amp;other.y),<br>            ordering =&gt; ordering,<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-built_in">PartialOrd</span> <span class="hljs-keyword">for</span> Point &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">partial_cmp</span></span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;<span class="hljs-keyword">Self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;Ordering&gt; &#123;<br>        <span class="hljs-literal">Some</span>(<span class="hljs-keyword">self</span>.cmp(other))<br>    &#125;<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-built_in">PartialEq</span> <span class="hljs-keyword">for</span> Point &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">eq</span></span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;<span class="hljs-keyword">Self</span>) -&gt; <span class="hljs-built_in">bool</span> &#123;<br>        <span class="hljs-keyword">self</span>.cmp(other) == Ordering::Equal<br>    &#125;<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-built_in">Eq</span> <span class="hljs-keyword">for</span> Point &#123;&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>特点</p><ol><li><p>表示集合论的全序</p><p> <a href="https://zh.wikipedia.org/wiki/%E5%85%A8%E5%BA%8F%E5%85%B3%E7%B3%BB">https://zh.wikipedia.org/wiki/全序关系</a></p><p> 集合中上的一个关系，这个关系对于集合中的所有元素均具有反对称性+传递性，那么这个关系在这个集合上就是全序（Order，全序）的</p><ol><li>a &lt; b implies !(a &gt; b) (asymmetry) 反对称性</li><li>a &lt; b &amp;&amp; b &lt; c implies a &lt; c (transitivity) 传递性</li></ol></li><li><p>Float 类型仅实现了PartialOrder Trait，但没有实现Order Trait</p><p> 因为NaN &lt; 0 &#x3D;&#x3D; false and NaN &gt;&#x3D; 0 &#x3D;&#x3D; false 这两个断言都是正确的，违反了对所有元素的“反对称性”</p></li></ol></li></ol><h3 id="5-Arithmetic-Traits"><a href="#5-Arithmetic-Traits" class="headerlink" title="5. Arithmetic Traits"></a>5. <strong><strong>Arithmetic Traits</strong></strong></h3><table><thead><tr><th>Trait(s)</th><th>Category</th><th>Operator(s)</th><th>Description</th></tr></thead><tbody><tr><td>Add</td><td>arithmetic</td><td>+</td><td>addition</td></tr><tr><td>AddAssign</td><td>arithmetic</td><td>+&#x3D;</td><td>addition assignment</td></tr><tr><td>BitAnd</td><td>arithmetic</td><td>&amp;</td><td>bitwise AND</td></tr><tr><td>BitAndAssign</td><td>arithmetic</td><td>&amp;&#x3D;</td><td>bitwise assignment</td></tr><tr><td>BitXor</td><td>arithmetic</td><td>^</td><td>bitwise XOR</td></tr><tr><td>BitXorAssign</td><td>arithmetic</td><td>^&#x3D;</td><td>bitwise XOR assignment</td></tr><tr><td>Div</td><td>arithmetic</td><td>&#x2F;</td><td>division</td></tr><tr><td>DivAssign</td><td>arithmetic</td><td>&#x2F;&#x3D;</td><td>division assignment</td></tr><tr><td>Mul</td><td>arithmetic</td><td>*</td><td>multiplication</td></tr><tr><td>MulAssign</td><td>arithmetic</td><td>*&#x3D;</td><td>multiplication assignment</td></tr><tr><td>Neg</td><td>arithmetic</td><td>-</td><td>unary negation</td></tr><tr><td>Not</td><td>arithmetic</td><td>!</td><td>unary logical negation</td></tr><tr><td>Rem</td><td>arithmetic</td><td>%</td><td>remainder</td></tr><tr><td>RemAssign</td><td>arithmetic</td><td>%&#x3D;</td><td>remainder assignment</td></tr><tr><td>Shl</td><td>arithmetic</td><td>&lt;&lt;</td><td>left shift</td></tr><tr><td>ShlAssign</td><td>arithmetic</td><td>&lt;&lt;&#x3D;</td><td>left shift assignment</td></tr><tr><td>Shr</td><td>arithmetic</td><td>&gt;&gt;</td><td>right shift</td></tr><tr><td>ShrAssign</td><td>arithmetic</td><td>&gt;&gt;&#x3D;</td><td>right shift assignment</td></tr><tr><td>Sub</td><td>arithmetic</td><td>-</td><td>subtraction</td></tr><tr><td>SubAssign</td><td>arithmetic</td><td>-&#x3D;</td><td>subtraction assignment</td></tr></tbody></table><h3 id="6-Closure-Traits"><a href="#6-Closure-Traits" class="headerlink" title="6. Closure Traits"></a>6. <strong><strong>Closure Traits</strong></strong></h3><table><thead><tr><th>Trait(s)</th><th>Category</th><th>Operator(s)</th><th>Description</th></tr></thead><tbody><tr><td>Fn</td><td>closure</td><td>(…args)</td><td>immutable closure invocation</td></tr><tr><td>FnMut</td><td>closure</td><td>(…args)</td><td>mutable closure invocation</td></tr><tr><td>FnOnce</td><td>closure</td><td>(…args)</td><td>one-time closure invocation</td></tr></tbody></table><p>包含三个Trait：Fn&#x2F;FnMut&#x2F;FnOnce</p><ol><li><p>定义</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">FnOnce</span></span>&lt;Args&gt; &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Output</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">call_once</span></span>(<span class="hljs-keyword">self</span>, args: Args) -&gt; Self::Output;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">FnMut</span></span>&lt;Args&gt;: <span class="hljs-built_in">FnOnce</span>&lt;Args&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">call_mut</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, args: Args) -&gt; Self::Output;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Fn</span></span>&lt;Args&gt;: <span class="hljs-built_in">FnMut</span>&lt;Args&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">call</span></span>(&amp;<span class="hljs-keyword">self</span>, args: Args) -&gt; Self::Output;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>实现</p><p> 虽然存在这些 trait，但是在 stable 的 Rust 中，我们无法为自己的类型实现这些 trait。我们能够创建的唯一能够实现这些 trait 的类型就是闭包。闭包根据其从环境中所捕获的内容来决定它到底是实现FnOnce、FnMut还是Fn。</p></li><li><p>特点</p><ol><li><p>FnOnce只能被调用一次</p><p> 执行这个闭包的时候会“移动”一些值</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> range = <span class="hljs-number">0</span>..<span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">let</span> get_range_count = || range.count();<br>    <span class="hljs-built_in">assert_eq!</span>(get_range_count(), <span class="hljs-number">10</span>); <span class="hljs-comment">// ✅</span><br>    get_range_count(); <span class="hljs-comment">// ❌</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>FnMut</p><ol><li><p>FnMut闭包可以被多次调用，并且可以修改它从环境中捕获到的变量。FnMut闭包是“有状态的”</p><p> 这是一个例子，闭包会修改外部的min，并将nums中所有不是升序的值删掉</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> nums = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>, <span class="hljs-number">7</span>, <span class="hljs-number">15</span>, <span class="hljs-number">18</span>, <span class="hljs-number">13</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> min = <span class="hljs-built_in">i32</span>::MIN;<br>    <span class="hljs-keyword">let</span> ascending = nums.into_iter().filter(|&amp;n| &#123;<br>        <span class="hljs-keyword">if</span> n &lt;= min &#123;<br>            <span class="hljs-literal">false</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            min = n;<br>            <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;).collect::&lt;<span class="hljs-built_in">Vec</span>&lt;_&gt;&gt;();<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">18</span>], ascending); <span class="hljs-comment">// ✅</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>FnMut是FnOnce的子集，</p><ul><li>FnOnce会获取它的参数的所有权并且只能被调用一次，</li><li>FnMut仅要求获取参数的可变引用并且可以被多次调用，</li><li>FnMut细化了FnOnce。FnMut可以被用于任何可以使用FnOnce的地方。</li></ul></li></ol></li><li><p>Fn</p><ol><li><p>Fn闭包也可以被调用多次，但是不能修改外部环境的变量，但可以访问。Fn是“无状态”的</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> nums = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>, <span class="hljs-number">7</span>, <span class="hljs-number">15</span>, <span class="hljs-number">18</span>, <span class="hljs-number">13</span>];<br>    <span class="hljs-keyword">let</span> min = <span class="hljs-number">9</span>;<br>    <span class="hljs-keyword">let</span> greater_than_9 = nums.into_iter().filter(|&amp;n| n &gt; min).collect::&lt;<span class="hljs-built_in">Vec</span>&lt;_&gt;&gt;();<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-built_in">vec!</span>[<span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">18</span>, <span class="hljs-number">13</span>], greater_than_9); <span class="hljs-comment">// ✅</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Fn是FnMut的子集</p><ul><li>FnMut要求可变引用并且可以被多次调用，</li><li>Fn只要求不可变引用并可以被多次调用，</li><li>Fn细化了FnMut。Fn可以被用于任何可以使用FnMut的地方，当然也包括可以使用FnOnce的地方。</li></ul></li></ol></li></ol></li><li><p>其他</p><ol><li>如果一个闭包不访问任何环境中的变量，从技术角度来讲它算不上是闭包，而只是一个被匿名声明的内联函数，并且可以作为一个普通函数指针（即Fn）被使用和传递，这包括可以使用FnMut和FnOnce的地方。 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">add_one</span></span>(x: <span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-built_in">i32</span> &#123;<br>    x + <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> fn_ptr: <span class="hljs-function"><span class="hljs-keyword">fn</span></span>(<span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-built_in">i32</span> = add_one;<br>    <span class="hljs-built_in">assert_eq!</span>(fn_ptr(<span class="hljs-number">1</span>), <span class="hljs-number">2</span>); <span class="hljs-comment">// ✅</span><br>    <br>    <span class="hljs-comment">// capture-less closure cast to fn pointer</span><br>    fn_ptr = |x| x + <span class="hljs-number">1</span>; <span class="hljs-comment">// same as add_one</span><br>    <span class="hljs-built_in">assert_eq!</span>(fn_ptr(<span class="hljs-number">1</span>), <span class="hljs-number">2</span>); <span class="hljs-comment">// ✅</span><br>&#125;<br></code></pre></td></tr></table></figure> 下面是一个传递普通函数指针而不是闭包的示例： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> nums = <span class="hljs-built_in">vec!</span>[-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, -<span class="hljs-number">3</span>, <span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">let</span> absolutes: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">i32</span>&gt; = nums.into_iter().map(<span class="hljs-built_in">i32</span>::abs).collect();<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>], absolutes); <span class="hljs-comment">// ✅</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h3 id="7-Deref-Trait"><a href="#7-Deref-Trait" class="headerlink" title="7. Deref Trait"></a>7. Deref Trait</h3><table><thead><tr><th>Trait(s)</th><th>Category</th><th>Operator(s)</th><th>Description</th><th></th></tr></thead><tbody><tr><td>Deref</td><td>other</td><td>*</td><td>immutable dereference</td><td>不可变引用</td></tr><tr><td>DerefMut</td><td>other</td><td>*</td><td>mutable derenence</td><td>可变引用</td></tr></tbody></table><ol><li><p>定义</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Deref</span></span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Target</span></span>: ?<span class="hljs-built_in">Sized</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deref</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;Self::Target;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">DerefMut</span></span>: Deref &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deref_mut</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; &amp;<span class="hljs-keyword">mut</span> Self::Target;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>功能</p><p> Deref&lt;Target &#x3D; T&gt;类型可以使用 * 操作符解引用为T类型。</p></li><li><p>特点</p><ol><li>当类型被作为函数参数传递、从函数返回或者作为方法调用的一部分时，Rust 会自动对这些类型进行解引用。<ol><li>我们可以在一个期望<code>&amp;str</code>和<code>&amp;[T]</code>的函数中可以传入<code>&amp;String</code>和<code>&amp;Vec&lt;T&gt;</code>，<ol><li><code>String</code>实现了<code>Deref&lt;Target = str&gt;</code></li><li><code>Vec&lt;T&gt;</code>实现了<code>Deref&lt;Target = [T]&gt;</code>。</li></ol></li></ol></li><li>Deref和DerefMut应该仅被实现于智能指针类型。</li><li>不要用deref来实现OOP的多态</li></ol></li></ol><h3 id="8-Index-amp-IndexMut"><a href="#8-Index-amp-IndexMut" class="headerlink" title="8. Index &amp; IndexMut"></a>8. <strong>Index &amp; IndexMut</strong></h3><ol><li><p>定义</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Index</span></span>&lt;Idx: ?<span class="hljs-built_in">Sized</span>&gt; &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Output</span></span>: ?<span class="hljs-built_in">Sized</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">index</span></span>(&amp;<span class="hljs-keyword">self</span>, index: Idx) -&gt; &amp;Self::Output;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">IndexMut</span></span>&lt;Idx&gt;: Index&lt;Idx&gt; <span class="hljs-keyword">where</span> Idx: ?<span class="hljs-built_in">Sized</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">index_mut</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, index: Idx) -&gt; &amp;<span class="hljs-keyword">mut</span> Self::Output;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>功能</p><ol><li>我们可以用[]索引具有 T 值的Index&lt;T, Output &#x3D; U&gt;类型，索引操作将返回&amp;U值。</li></ol></li><li><p>特点</p><ol><li><p>索引操作后，编译器默认在返回值前插入解引用</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-comment">// Vec&lt;i32&gt; impls Index&lt;usize, Output = i32&gt; so</span><br>    <span class="hljs-comment">// indexing Vec&lt;i32&gt; should produce &amp;i32s and yet...</span><br>    <span class="hljs-keyword">let</span> vec = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">let</span> num_ref: &amp;<span class="hljs-built_in">i32</span> = vec[<span class="hljs-number">0</span>]; <span class="hljs-comment">// ❌ expected &amp;i32 found i32</span><br>    <br>    <span class="hljs-comment">// above line actually desugars to</span><br>    <span class="hljs-keyword">let</span> num_ref: &amp;<span class="hljs-built_in">i32</span> = *vec[<span class="hljs-number">0</span>]; <span class="hljs-comment">// ❌ expected &amp;i32 found i32</span><br><br>    <span class="hljs-comment">// both of these alternatives work</span><br>    <span class="hljs-keyword">let</span> num: <span class="hljs-built_in">i32</span> = vec[<span class="hljs-number">0</span>]; <span class="hljs-comment">// ✅</span><br>    <span class="hljs-keyword">let</span> num_ref = &amp;vec[<span class="hljs-number">0</span>]; <span class="hljs-comment">// ✅</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>用来索引的Idx是一个泛型，举几个其他类型用来索引的例子</p><ol><li><p>可以是usize</p></li><li><p>可以是其他整数类型</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::ops::Index;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">WrappingIndex</span></span>&lt;T&gt;(<span class="hljs-built_in">Vec</span>&lt;T&gt;);<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; Index&lt;<span class="hljs-built_in">usize</span>&gt; <span class="hljs-keyword">for</span> WrappingIndex&lt;T&gt; &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Output</span></span> = T;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">index</span></span>(&amp;<span class="hljs-keyword">self</span>, index: <span class="hljs-built_in">usize</span>) -&gt; &amp;T &#123;<br>        &amp;<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>[index % <span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>.len()]<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; Index&lt;<span class="hljs-built_in">i128</span>&gt; <span class="hljs-keyword">for</span> WrappingIndex&lt;T&gt; &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Output</span></span> = T;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">index</span></span>(&amp;<span class="hljs-keyword">self</span>, index: <span class="hljs-built_in">i128</span>) -&gt; &amp;T &#123;<br>        <span class="hljs-keyword">let</span> self_len = <span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>.len() <span class="hljs-keyword">as</span> <span class="hljs-built_in">i128</span>;<br>        <span class="hljs-keyword">let</span> idx = (((index % self_len) + self_len) % self_len) <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>;<br>        &amp;<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>[idx]<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">#[test]</span> <span class="hljs-comment">// ✅</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">indexes</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> wrapping_vec = WrappingIndex(<span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">1</span>, wrapping_vec[<span class="hljs-number">0_usize</span>]);<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">2</span>, wrapping_vec[<span class="hljs-number">1_usize</span>]);<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">3</span>, wrapping_vec[<span class="hljs-number">2_usize</span>]);<br>&#125;<br><br><span class="hljs-meta">#[test]</span> <span class="hljs-comment">// ✅</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">wrapping_indexes</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> wrapping_vec = WrappingIndex(<span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">1</span>, wrapping_vec[<span class="hljs-number">3_usize</span>]);<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">2</span>, wrapping_vec[<span class="hljs-number">4_usize</span>]);<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">3</span>, wrapping_vec[<span class="hljs-number">5_usize</span>]);<br>&#125;<br><br><span class="hljs-meta">#[test]</span> <span class="hljs-comment">// ✅</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">neg_indexes</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> wrapping_vec = WrappingIndex(<span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">1</span>, wrapping_vec[-<span class="hljs-number">3_i128</span>]);<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">2</span>, wrapping_vec[-<span class="hljs-number">2_i128</span>]);<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">3</span>, wrapping_vec[-<span class="hljs-number">1_i128</span>]);<br>&#125;<br><br><span class="hljs-meta">#[test]</span> <span class="hljs-comment">// ✅</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">wrapping_neg_indexes</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> wrapping_vec = WrappingIndex(<span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">1</span>, wrapping_vec[-<span class="hljs-number">6_i128</span>]);<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">2</span>, wrapping_vec[-<span class="hljs-number">5_i128</span>]);<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">3</span>, wrapping_vec[-<span class="hljs-number">4_i128</span>]);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>可以是满足 Range<usize> 的类型</p><p> 下面这个例子中，1.. &#x2F;..4&#x2F;1..4 都是满足 Range<usize> 的类型</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> vec = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br>    <span class="hljs-built_in">assert_eq!</span>(&amp;vec[..], &amp;[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]); <span class="hljs-comment">// ✅</span><br>    <span class="hljs-built_in">assert_eq!</span>(&amp;vec[<span class="hljs-number">1</span>..], &amp;[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]); <span class="hljs-comment">// ✅</span><br>    <span class="hljs-built_in">assert_eq!</span>(&amp;vec[..<span class="hljs-number">4</span>], &amp;[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]); <span class="hljs-comment">// ✅</span><br>    <span class="hljs-built_in">assert_eq!</span>(&amp;vec[<span class="hljs-number">1</span>..<span class="hljs-number">4</span>], &amp;[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]); <span class="hljs-comment">// ✅</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>可以是枚举</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::ops::Index;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">BasketballPosition</span></span> &#123;<br>    PointGuard,<br>    ShootingGuard,<br>    Center,<br>    PowerForward,<br>    SmallForward,<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BasketballPlayer</span></span> &#123;<br>    name: &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-built_in">str</span>,<br>    position: BasketballPosition,<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BasketballTeam</span></span> &#123;<br>    point_guard: BasketballPlayer,<br>    shooting_guard: BasketballPlayer,<br>    center: BasketballPlayer,<br>    power_forward: BasketballPlayer,<br>    small_forward: BasketballPlayer,<br>&#125;<br><br><span class="hljs-keyword">impl</span> Index&lt;BasketballPosition&gt; <span class="hljs-keyword">for</span> BasketballTeam &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Output</span></span> = BasketballPlayer;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">index</span></span>(&amp;<span class="hljs-keyword">self</span>, position: BasketballPosition) -&gt; &amp;BasketballPlayer &#123;<br>        <span class="hljs-keyword">match</span> position &#123;<br>            BasketballPosition::PointGuard =&gt; &amp;<span class="hljs-keyword">self</span>.point_guard,<br>            BasketballPosition::ShootingGuard =&gt; &amp;<span class="hljs-keyword">self</span>.shooting_guard,<br>            BasketballPosition::Center =&gt; &amp;<span class="hljs-keyword">self</span>.center,<br>            BasketballPosition::PowerForward =&gt; &amp;<span class="hljs-keyword">self</span>.power_forward,<br>            BasketballPosition::SmallForward =&gt; &amp;<span class="hljs-keyword">self</span>.small_forward,<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol></li></ol><h3 id="8-Drop-Trait"><a href="#8-Drop-Trait" class="headerlink" title="8. Drop Trait"></a>8. Drop Trait</h3><ol><li><p>定义</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Drop</span></span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">drop</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>作用</p><p> drop函数会在该类型离开作用域但是销毁之前被调用。用来销毁某些外部资源</p></li><li><p>例子</p><ol><li><p>标准库中有一个BufWriter类型让我们能够把写入的数据缓冲到Write类型中。</p><p> 为了避免Bufwriter的内容在写入底层write类型之前就被销毁，Bufwirter实现了Drop Trait</p><p> 让Bufwriter对象在销毁前保证刷新缓冲区</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;W: Write&gt; <span class="hljs-built_in">Drop</span> <span class="hljs-keyword">for</span> BufWriter&lt;W&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">drop</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">self</span>.flush_buf();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Rust 中的Mutexs没有unlock()方法，因为它们不需要！</p><ol><li>在Mutex上调用lock()会返回一个MutexGuard，</li><li>当MutexGuard离开作用域时，它会调用drop函数自动解锁（unlock）Mutex，</li></ol> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;T: ?<span class="hljs-built_in">Sized</span>&gt; <span class="hljs-built_in">Drop</span> <span class="hljs-keyword">for</span> MutexGuard&lt;<span class="hljs-symbol">&#x27;_</span>, T&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">drop</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">unsafe</span> &#123;<br>            <span class="hljs-keyword">self</span>.lock.inner.raw_unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h2 id="六、Conversion-Traits"><a href="#六、Conversion-Traits" class="headerlink" title="六、Conversion Traits"></a>六、<strong><strong>Conversion Traits</strong></strong></h2><h3 id="1-From-amp-Into"><a href="#1-From-amp-Into" class="headerlink" title="1. From&amp;Into"></a>1. From&amp;Into</h3><ol><li><p>定义</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">From</span></span>&lt;T&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">from</span></span>(T) -&gt; <span class="hljs-keyword">Self</span>;<br>&#125;<br></code></pre></td></tr></table></figure> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Into</span></span>&lt;T&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">into</span></span>(<span class="hljs-keyword">self</span>) -&gt; T;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T, U&gt; <span class="hljs-built_in">Into</span>&lt;U&gt; <span class="hljs-keyword">for</span> T<br><span class="hljs-keyword">where</span><br>    U: <span class="hljs-built_in">From</span>&lt;T&gt;,<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">into</span></span>(<span class="hljs-keyword">self</span>) -&gt; U &#123;<br>        U::from(<span class="hljs-keyword">self</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>作用</p><ol><li>From Trait允许把T类型转换为Self类型（通常为自己实现的类型）</li><li>只能为自己的类型实现From<T>，因为Into<T>的实现会通过 generic blanket impl 自动提供</li></ol></li><li><p>使用例子</p><ol><li><p>基础例子</p><ol><li><p>可以从（x,y）tuple或者 array 转换为Point类型</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span></span> &#123;<br>    x: <span class="hljs-built_in">i32</span>,<br>    y: <span class="hljs-built_in">i32</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-built_in">From</span>&lt;(<span class="hljs-built_in">i32</span>, <span class="hljs-built_in">i32</span>)&gt; <span class="hljs-keyword">for</span> Point &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">from</span></span>((x, y): (<span class="hljs-built_in">i32</span>, <span class="hljs-built_in">i32</span>)) -&gt; <span class="hljs-keyword">Self</span> &#123;<br>        Point &#123; x, y &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-built_in">From</span>&lt;Point&gt; <span class="hljs-keyword">for</span> (<span class="hljs-built_in">i32</span>, <span class="hljs-built_in">i32</span>) &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">from</span></span>(Point &#123; x, y &#125;: Point) -&gt; <span class="hljs-keyword">Self</span> &#123;<br>        (x, y)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-built_in">From</span>&lt;[<span class="hljs-built_in">i32</span>; <span class="hljs-number">2</span>]&gt; <span class="hljs-keyword">for</span> Point &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">from</span></span>([x, y]: [<span class="hljs-built_in">i32</span>; <span class="hljs-number">2</span>]) -&gt; <span class="hljs-keyword">Self</span> &#123;<br>        Point &#123; x, y &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-built_in">From</span>&lt;Point&gt; <span class="hljs-keyword">for</span> [<span class="hljs-built_in">i32</span>; <span class="hljs-number">2</span>] &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">from</span></span>(Point &#123; x, y &#125;: Point) -&gt; <span class="hljs-keyword">Self</span> &#123;<br>        [x, y]<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">example</span></span>() &#123;<br>    <span class="hljs-comment">// 从 (i32, i32) 到 Point</span><br>    <span class="hljs-keyword">let</span> point = Point::from((<span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">let</span> point: Point = (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>).into();<br><br>    <span class="hljs-comment">// 从 Point 到 (i32, i32)</span><br>    <span class="hljs-keyword">let</span> tuple = &lt;(<span class="hljs-built_in">i32</span>, <span class="hljs-built_in">i32</span>)&gt;::from(point);<br>    <span class="hljs-keyword">let</span> tuple: (<span class="hljs-built_in">i32</span>, <span class="hljs-built_in">i32</span>) = point.into();<br><br>    <span class="hljs-comment">// 从 [i32; 2] 到 Point</span><br>    <span class="hljs-keyword">let</span> point = Point::from([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">let</span> point: Point = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>].into();<br><br>    <span class="hljs-comment">// 从 Point 到 [i32; 2]</span><br>    <span class="hljs-keyword">let</span> array = &lt;[<span class="hljs-built_in">i32</span>; <span class="hljs-number">2</span>]&gt;::from(point);<br>    <span class="hljs-keyword">let</span> array: [<span class="hljs-built_in">i32</span>; <span class="hljs-number">2</span>] = point.into();<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>使得“需要对参数拥有所有权的”函数具有通用型，不关心传进来的参数是拥有值还是值得引用</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span></span> &#123;<br>    name: <span class="hljs-built_in">String</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> Person &#123;<br>    <span class="hljs-comment">// 接受:</span><br>    <span class="hljs-comment">// - String</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new1</span></span>(name: <span class="hljs-built_in">String</span>) -&gt; Person &#123;<br>        Person &#123; name &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 接受:</span><br>    <span class="hljs-comment">// - String</span><br>    <span class="hljs-comment">// - &amp;String</span><br>    <span class="hljs-comment">// - &amp;str</span><br>    <span class="hljs-comment">// - Box&lt;str&gt;</span><br>    <span class="hljs-comment">// - Cow&lt;&#x27;_, str&gt;</span><br>    <span class="hljs-comment">// - char</span><br>    <span class="hljs-comment">// 因为上面所有的类型都可以转换为 String</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new2</span></span>&lt;N: <span class="hljs-built_in">Into</span>&lt;<span class="hljs-built_in">String</span>&gt;&gt;(name: N) -&gt; Person &#123;<br>        Person &#123; name: name.into() &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h2 id="七、错误处理"><a href="#七、错误处理" class="headerlink" title="七、错误处理"></a>七、错误处理</h2><h3 id="1-Error-Trait"><a href="#1-Error-Trait" class="headerlink" title="1. Error Trait"></a>1. Error Trait</h3><ol><li><p>定义</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Error</span></span>: <span class="hljs-built_in">Debug</span> + Display &#123;<br>    <span class="hljs-comment">// 提供默认实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">source</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;&amp;(<span class="hljs-keyword">dyn</span> Error + <span class="hljs-symbol">&#x27;static</span>)&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">backtrace</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;&amp;Backtrace&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">description</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;<span class="hljs-built_in">str</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">cause</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;&amp;<span class="hljs-keyword">dyn</span> Error&gt;;<br>&#125; <br></code></pre></td></tr></table></figure></li><li><p>功能</p><ol><li>rust中，错误是被return返回的，而不是被throw抛出的</li></ol></li><li><p>一个例子</p><ol><li><p>安全除法</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt;<br><span class="hljs-keyword">use</span> std::error;<br><br><span class="hljs-meta">#[derive(Debug, PartialEq)]</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DivByZero</span></span>;<br><br><span class="hljs-keyword">impl</span> fmt::Display <span class="hljs-keyword">for</span> DivByZero &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">fmt</span></span>(&amp;<span class="hljs-keyword">self</span>, f: &amp;<span class="hljs-keyword">mut</span> fmt::Formatter&lt;<span class="hljs-symbol">&#x27;_</span>&gt;) -&gt; fmt::<span class="hljs-built_in">Result</span> &#123;<br>        <span class="hljs-built_in">write!</span>(f, <span class="hljs-string">&quot;division by zero error&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> error::Error <span class="hljs-keyword">for</span> DivByZero &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">safe_div</span></span>(numerator: <span class="hljs-built_in">i32</span>, denominator: <span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">i32</span>, DivByZero&gt; &#123;<br>    <span class="hljs-keyword">if</span> denominator == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(DivByZero);<br>    &#125;<br>    <span class="hljs-literal">Ok</span>(numerator / denominator)<br>&#125;<br><br><span class="hljs-meta">#[test]</span> <span class="hljs-comment">// ✅</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">test_safe_div</span></span>() &#123;<br>    <span class="hljs-built_in">assert_eq!</span>(safe_div(<span class="hljs-number">8</span>, <span class="hljs-number">2</span>), <span class="hljs-literal">Ok</span>(<span class="hljs-number">4</span>));<br>    <span class="hljs-built_in">assert_eq!</span>(safe_div(<span class="hljs-number">5</span>, <span class="hljs-number">0</span>), <span class="hljs-literal">Err</span>(DivByZero));<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>特点</p><ol><li><p>错误是被返回而不是被抛出，所以这些错误必须被显式地处理，如果当前函数无法处理错误，该函数应该把错误传递给自己的调用者。</p></li><li><p>传递错误的最常用方式是使用?操作符，它是现在已经弃用的try!宏的语法糖</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">macro_rules!</span> <span class="hljs-keyword">try</span> &#123;<br>    ($expr:expr) =&gt; &#123;<br>        <span class="hljs-keyword">match</span> $expr &#123;<br>            <span class="hljs-comment">// if Ok just unwrap the value</span><br>            <span class="hljs-literal">Ok</span>(val) =&gt; val,<br>            <span class="hljs-comment">// if Err map the err value using From and return</span><br>            <span class="hljs-literal">Err</span>(err) =&gt; &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(<span class="hljs-built_in">From</span>::from(err));<br>            &#125;<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>一个返回io::Error的例子</p><ol><li><p>这个例子中，所有可能的error都是io::Error类型的</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io::Read;<br><span class="hljs-keyword">use</span> std::path::Path;<br><span class="hljs-keyword">use</span> std::io;<br><span class="hljs-keyword">use</span> std::fs::File;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">read_file_to_string</span></span>(path: &amp;Path) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">String</span>, io::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> file = File::open(path)?; <span class="hljs-comment">// ⬆️ io::Error</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> contents = <span class="hljs-built_in">String</span>::new();<br>    file.read_to_string(&amp;<span class="hljs-keyword">mut</span> contents)?; <span class="hljs-comment">// ⬆️ io::Error</span><br>    <span class="hljs-literal">Ok</span>(contents)<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>如何返回不同种类的Error</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io::Read;<br><span class="hljs-keyword">use</span> std::path::Path;<br><span class="hljs-keyword">use</span> std::io;<br><span class="hljs-keyword">use</span> std::fs::File;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">sum_file</span></span>(path: &amp;Path) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">i32</span>, <span class="hljs-comment">/*这里放置什么? */</span>&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> file = File::open(path)?; <span class="hljs-comment">// ⬆️ io::Error</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> contents = <span class="hljs-built_in">String</span>::new();<br>    file.read_to_string(&amp;<span class="hljs-keyword">mut</span> contents)?; <span class="hljs-comment">// ⬆️ io::Error</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> contents.lines() &#123;<br>        sum += line.parse::&lt;<span class="hljs-built_in">i32</span>&gt;()?; <span class="hljs-comment">// ⬆️ ParseIntError</span><br>    &#125;<br>    <span class="hljs-literal">Ok</span>(sum)<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>一种方法是，使用dyn error::Error 接受任意类型Error</p><ol><li><p>任何一种error类型均可以转换为Box<dyn error::Error> 类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;E: error::Error&gt; <span class="hljs-built_in">From</span>&lt;E&gt; <span class="hljs-keyword">for</span> <span class="hljs-built_in">Box</span>&lt;<span class="hljs-keyword">dyn</span> error::Error&gt;;<br></code></pre></td></tr></table></figure></li><li><p>所以，任意一种Error均可以通过Box<dyn error::Error> 返回给调用者</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">use</span> std::io::Read;<br><span class="hljs-keyword">use</span> std::path::Path;<br><span class="hljs-keyword">use</span> std::error;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">sum_file</span></span>(path: &amp;Path) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">i32</span>, <span class="hljs-built_in">Box</span>&lt;<span class="hljs-keyword">dyn</span> error::Error&gt;&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> file = File::open(path)?; <span class="hljs-comment">// ⬆️ io::Error -&gt; Box&lt;dyn error::Error&gt;</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> contents = <span class="hljs-built_in">String</span>::new();<br>    file.read_to_string(&amp;<span class="hljs-keyword">mut</span> contents)?; <span class="hljs-comment">// ⬆️ io::Error -&gt; Box&lt;dyn error::Error&gt;</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> contents.lines() &#123;<br>        sum += line.parse::&lt;<span class="hljs-built_in">i32</span>&gt;()?; <span class="hljs-comment">// ⬆️ ParseIntError -&gt; Box&lt;dyn error::Error&gt;</span><br>    &#125;<br>    <span class="hljs-literal">Ok</span>(sum)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>如果调用者想知道返回错误的具体类型，需要使用downcast_ref()</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">handle_sum_file_errors</span></span>(path: &amp;Path) &#123;<br>    <span class="hljs-keyword">match</span> sum_file(path) &#123;<br>        <span class="hljs-literal">Ok</span>(sum) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;the sum is &#123;&#125;&quot;</span>, sum),<br>        <span class="hljs-literal">Err</span>(err) =&gt; &#123;<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(e) = err.downcast_ref::&lt;io::Error&gt;() &#123;<br>                <span class="hljs-comment">// 处理 io::Error</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(e) = err.downcast_ref::&lt;ParseIntError&gt;() &#123;<br>                <span class="hljs-comment">// 处理 ParseIntError</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 我们知道 sum_file 只会返回上面错误中的其中一个</span><br>                <span class="hljs-comment">// 所以不会到达这个分支</span><br>                <span class="hljs-built_in">unreachable!</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>第二种方法是：使用Enum类型枚举所有可能的error</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::num::ParseIntError;<br><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">use</span> std::io;<br><span class="hljs-keyword">use</span> std::io::Read;<br><span class="hljs-keyword">use</span> std::path::Path;<br><span class="hljs-keyword">use</span> std::error;<br><span class="hljs-keyword">use</span> std::fmt;<br><br><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SumFileError</span></span> &#123;<br>    Io(io::Error),<br>    Parse(ParseIntError),<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-built_in">From</span>&lt;io::Error&gt; <span class="hljs-keyword">for</span> SumFileError &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">from</span></span>(err: io::Error) -&gt; <span class="hljs-keyword">Self</span> &#123;<br>        SumFileError::Io(err)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-built_in">From</span>&lt;ParseIntError&gt; <span class="hljs-keyword">for</span> SumFileError &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">from</span></span>(err: ParseIntError) -&gt; <span class="hljs-keyword">Self</span> &#123;<br>        SumFileError::Parse(err)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> fmt::Display <span class="hljs-keyword">for</span> SumFileError &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">fmt</span></span>(&amp;<span class="hljs-keyword">self</span>, f: &amp;<span class="hljs-keyword">mut</span> fmt::Formatter&lt;<span class="hljs-symbol">&#x27;_</span>&gt;) -&gt; fmt::<span class="hljs-built_in">Result</span> &#123;<br>        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span> &#123;<br>            SumFileError::Io(err) =&gt; <span class="hljs-built_in">write!</span>(f, <span class="hljs-string">&quot;sum file error: &#123;&#125;&quot;</span>, err),<br>            SumFileError::Parse(err) =&gt; <span class="hljs-built_in">write!</span>(f, <span class="hljs-string">&quot;sum file error: &#123;&#125;&quot;</span>, err),<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> error::Error <span class="hljs-keyword">for</span> SumFileError &#123;<br>    <span class="hljs-comment">// 这个方法的默认实现总是返回 None</span><br>    <span class="hljs-comment">//但是我们现在重写它，让它更有用    </span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">source</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;&amp;(<span class="hljs-keyword">dyn</span> error::Error + <span class="hljs-symbol">&#x27;static</span>)&gt; &#123;<br>        <span class="hljs-literal">Some</span>(<span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span> &#123;<br>            SumFileError::Io(err) =&gt; err,<br>            SumFileError::Parse(err) =&gt; err,<br>        &#125;)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">sum_file</span></span>(path: &amp;Path) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">i32</span>, SumFileError&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> file = File::open(path)?; <span class="hljs-comment">// ⬆️ io::Error -&gt; SumFileError</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> contents = <span class="hljs-built_in">String</span>::new();<br>    file.read_to_string(&amp;<span class="hljs-keyword">mut</span> contents)?; <span class="hljs-comment">// ⬆️ io::Error -&gt; SumFileError</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> contents.lines() &#123;<br>        sum += line.parse::&lt;<span class="hljs-built_in">i32</span>&gt;()?; <span class="hljs-comment">// ⬆️ ParseIntError -&gt; SumFileError</span><br>    &#125;<br>    <span class="hljs-literal">Ok</span>(sum)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">handle_sum_file_errors</span></span>(path: &amp;Path) &#123;<br>    <span class="hljs-keyword">match</span> sum_file(path) &#123;<br>        <span class="hljs-literal">Ok</span>(sum) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;the sum is &#123;&#125;&quot;</span>, sum),<br>        <span class="hljs-literal">Err</span>(SumFileError::Io(err)) =&gt; &#123;<br>            <span class="hljs-comment">// 处理 io::Error</span><br>        &#125;,<br>        <span class="hljs-literal">Err</span>(SumFileError::Parse(err)) =&gt; &#123;<br>            <span class="hljs-comment">// 处理 ParseIntError</span><br>        &#125;,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol></li></ol><h2 id="六、转换类型（续）"><a href="#六、转换类型（续）" class="headerlink" title="六、转换类型（续）"></a>六、转换类型（续）</h2><h3 id="1-TryFrom-amp-TryInto"><a href="#1-TryFrom-amp-TryInto" class="headerlink" title="1. TryFrom &amp; TryInto"></a>1. TryFrom &amp; TryInto</h3><ol><li><p>定义</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">TryFrom</span></span>&lt;T&gt; &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Error</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">try_from</span></span>(value: T) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-keyword">Self</span>, Self::Error&gt;;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">TryInto</span></span>&lt;T&gt; &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Error</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">try_into</span></span>(<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;T, Self::Error&gt;;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>功能：允许失败版本的From&#x2F;Into</p></li><li><p>一个例子</p><ol><li><p>Point中的x和y如果值小于-1000或者大于1000没有意义，则可以如下实现转换函数</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::convert::TryFrom;<br><span class="hljs-keyword">use</span> std::error;<br><span class="hljs-keyword">use</span> std::fmt;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span></span> &#123;<br>    x: <span class="hljs-built_in">i32</span>,<br>    y: <span class="hljs-built_in">i32</span>,<br>&#125;<br><br><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">OutOfBounds</span></span>;<br><br><span class="hljs-keyword">impl</span> fmt::Display <span class="hljs-keyword">for</span> OutOfBounds &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">fmt</span></span>(&amp;<span class="hljs-keyword">self</span>, f: &amp;<span class="hljs-keyword">mut</span> fmt::Formatter&lt;<span class="hljs-symbol">&#x27;_</span>&gt;) -&gt; fmt::<span class="hljs-built_in">Result</span> &#123;<br>        <span class="hljs-built_in">write!</span>(f, <span class="hljs-string">&quot;out of bounds&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> error::Error <span class="hljs-keyword">for</span> OutOfBounds &#123;&#125;<br><br><span class="hljs-comment">// 现在是可以出错的</span><br><span class="hljs-keyword">impl</span> TryFrom&lt;(<span class="hljs-built_in">i32</span>, <span class="hljs-built_in">i32</span>)&gt; <span class="hljs-keyword">for</span> Point &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Error</span></span> = OutOfBounds;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">try_from</span></span>((x, y): (<span class="hljs-built_in">i32</span>, <span class="hljs-built_in">i32</span>)) -&gt; <span class="hljs-built_in">Result</span>&lt;Point, OutOfBounds&gt; &#123;<br>        <span class="hljs-keyword">if</span> x.abs() &gt; <span class="hljs-number">1000</span> || y.abs() &gt; <span class="hljs-number">1000</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(OutOfBounds);<br>        &#125;<br>        <span class="hljs-literal">Ok</span>(Point &#123; x, y &#125;)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 仍然是不会出错的</span><br><span class="hljs-keyword">impl</span> <span class="hljs-built_in">From</span>&lt;Point&gt; <span class="hljs-keyword">for</span> (<span class="hljs-built_in">i32</span>, <span class="hljs-built_in">i32</span>) &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">from</span></span>(Point &#123; x, y &#125;: Point) -&gt; <span class="hljs-keyword">Self</span> &#123;<br>        (x, y)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h3 id="2-FromStr"><a href="#2-FromStr" class="headerlink" title="2. FromStr"></a>2. FromStr</h3><ol><li><p>定义</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">FromStr</span></span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Err</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">from_str</span></span>(s: &amp;<span class="hljs-built_in">str</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-keyword">Self</span>, Self::<span class="hljs-literal">Err</span>&gt;;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>功能</p><p> FromStr 类型允许执行一个从&amp;str到Self的可失败的转换。最常见的使用是在&amp;str上调用.parse()方法。</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::<span class="hljs-built_in">str</span>::FromStr;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">example</span></span>&lt;T: FromStr&gt;(s: &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-built_in">str</span>) &#123;<br>    <span class="hljs-comment">// 这些都是相等的</span><br>    <span class="hljs-keyword">let</span> t: <span class="hljs-built_in">Result</span>&lt;T, _&gt; = FromStr::from_str(s);<br>    <span class="hljs-keyword">let</span> t = T::from_str(s);<br>    <span class="hljs-keyword">let</span> t: <span class="hljs-built_in">Result</span>&lt;T, _&gt; = s.parse();<br>    <span class="hljs-keyword">let</span> t = s.parse::&lt;T&gt;(); <span class="hljs-comment">// 最常见的</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>一个例子</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::error;<br><span class="hljs-keyword">use</span> std::fmt;<br><span class="hljs-keyword">use</span> std::iter::Enumerate;<br><span class="hljs-keyword">use</span> std::num::ParseIntError;<br><span class="hljs-keyword">use</span> std::<span class="hljs-built_in">str</span>::&#123;Chars, FromStr&#125;;<br><br><span class="hljs-meta">#[derive(Debug, Eq, PartialEq)]</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span></span> &#123;<br>    x: <span class="hljs-built_in">i32</span>,<br>    y: <span class="hljs-built_in">i32</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> Point &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>(x: <span class="hljs-built_in">i32</span>, y: <span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-keyword">Self</span> &#123;<br>        Point &#123; x, y &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">#[derive(Debug, PartialEq)]</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ParsePointError</span></span>;<br><br><span class="hljs-keyword">impl</span> fmt::Display <span class="hljs-keyword">for</span> ParsePointError &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">fmt</span></span>(&amp;<span class="hljs-keyword">self</span>, f: &amp;<span class="hljs-keyword">mut</span> fmt::Formatter&lt;<span class="hljs-symbol">&#x27;_</span>&gt;) -&gt; fmt::<span class="hljs-built_in">Result</span> &#123;<br>        <span class="hljs-built_in">write!</span>(f, <span class="hljs-string">&quot;failed to parse point&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-built_in">From</span>&lt;ParseIntError&gt; <span class="hljs-keyword">for</span> ParsePointError &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">from</span></span>(_e: ParseIntError) -&gt; <span class="hljs-keyword">Self</span> &#123;<br>        ParsePointError<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> error::Error <span class="hljs-keyword">for</span> ParsePointError &#123;&#125;<br><br><span class="hljs-keyword">impl</span> FromStr <span class="hljs-keyword">for</span> Point &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Err</span></span> = ParsePointError;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">from_str</span></span>(s: &amp;<span class="hljs-built_in">str</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-keyword">Self</span>, Self::<span class="hljs-literal">Err</span>&gt; &#123;<br>        <span class="hljs-keyword">let</span> is_num = |(_, c): &amp;(<span class="hljs-built_in">usize</span>, <span class="hljs-built_in">char</span>)| matches!(c, <span class="hljs-string">&#x27;0&#x27;</span>..=<span class="hljs-string">&#x27;9&#x27;</span> | <span class="hljs-string">&#x27;-&#x27;</span>);<br>        <span class="hljs-keyword">let</span> isnt_num = |t: &amp;(_, _)| !is_num(t);<br><br>        <span class="hljs-keyword">let</span> get_num =<br>            |char_idxs: &amp;<span class="hljs-keyword">mut</span> Enumerate&lt;Chars&lt;<span class="hljs-symbol">&#x27;_</span>&gt;&gt;| -&gt; <span class="hljs-built_in">Result</span>&lt;(<span class="hljs-built_in">usize</span>, <span class="hljs-built_in">usize</span>), ParsePointError&gt; &#123;<br>                <span class="hljs-keyword">let</span> (start, _) = char_idxs<br>                    .skip_while(isnt_num)<br>                    .next()<br>                    .ok_or(ParsePointError)?;<br>                <span class="hljs-keyword">let</span> (end, _) = char_idxs<br>                    .skip_while(is_num)<br>                    .next()<br>                    .ok_or(ParsePointError)?;<br>                <span class="hljs-literal">Ok</span>((start, end))<br>            &#125;;<br><br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> char_idxs = s.chars().enumerate();<br>        <span class="hljs-keyword">let</span> (x_start, x_end) = get_num(&amp;<span class="hljs-keyword">mut</span> char_idxs)?;<br>        <span class="hljs-keyword">let</span> (y_start, y_end) = get_num(&amp;<span class="hljs-keyword">mut</span> char_idxs)?;<br><br>        <span class="hljs-keyword">let</span> x = s[x_start..x_end].parse::&lt;<span class="hljs-built_in">i32</span>&gt;()?;<br>        <span class="hljs-keyword">let</span> y = s[y_start..y_end].parse::&lt;<span class="hljs-built_in">i32</span>&gt;()?;<br><br>        <span class="hljs-literal">Ok</span>(Point &#123; x, y &#125;)<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">#[test]</span> <span class="hljs-comment">// ✅</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">pos_x_y</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> p = <span class="hljs-string">&quot;(4, 5)&quot;</span>.parse::&lt;Point&gt;();<br>    <span class="hljs-built_in">assert_eq!</span>(p, <span class="hljs-literal">Ok</span>(Point::new(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)));<br>&#125;<br><br><span class="hljs-meta">#[test]</span> <span class="hljs-comment">// ✅</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">neg_x_y</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> p = <span class="hljs-string">&quot;(-6, -2)&quot;</span>.parse::&lt;Point&gt;();<br>    <span class="hljs-built_in">assert_eq!</span>(p, <span class="hljs-literal">Ok</span>(Point::new(-<span class="hljs-number">6</span>, -<span class="hljs-number">2</span>)));<br>&#125;<br><br><span class="hljs-meta">#[test]</span> <span class="hljs-comment">// ✅</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">not_a_point</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> p = <span class="hljs-string">&quot;not a point&quot;</span>.parse::&lt;Point&gt;();<br>    <span class="hljs-built_in">assert_eq!</span>(p, <span class="hljs-literal">Err</span>(ParsePointError));<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>特点</p><ol><li><p>FromStr和TryFrom&lt;&amp;str&gt;有着相同的签名。只要我们通过其中一个实现另一个，先实现哪个并不重要。</p><ol><li>一个例子</li></ol> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> TryFrom&lt;&amp;<span class="hljs-built_in">str</span>&gt; <span class="hljs-keyword">for</span> Point &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Error</span></span> = &lt;Point <span class="hljs-keyword">as</span> FromStr&gt;::<span class="hljs-literal">Err</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">try_from</span></span>(s: &amp;<span class="hljs-built_in">str</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;Point, Self::Error&gt; &#123;<br>        &lt;Point <span class="hljs-keyword">as</span> FromStr&gt;::from_str(s)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h3 id="2-AsRef-amp-AsMut"><a href="#2-AsRef-amp-AsMut" class="headerlink" title="2. AsRef &amp; AsMut"></a>2. <strong><strong>AsRef &amp; AsMut</strong></strong></h3><ol><li><p>定义</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">AsRef</span></span>&lt;T: ?<span class="hljs-built_in">Sized</span>&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">as_ref</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;T;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">AsMut</span></span>&lt;T: ?<span class="hljs-built_in">Sized</span>&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">as_mut</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; &amp;<span class="hljs-keyword">mut</span> T;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>作用：</p><ol><li><p>总的来说，AsRef被用于轻量级的引用到引用之间的转换。下面举几个实际的例子</p></li><li><p>AsRef trait可以使函数在是否获取所有权上具有通用性：</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// accepts:</span><br><span class="hljs-comment">//  - &amp;str</span><br><span class="hljs-comment">//  - &amp;String</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">takes_str</span></span>(s: &amp;<span class="hljs-built_in">str</span>) &#123;<br>    <span class="hljs-comment">// use &amp;str</span><br>&#125;<br><br><span class="hljs-comment">// accepts:</span><br><span class="hljs-comment">//  - &amp;str</span><br><span class="hljs-comment">//  - &amp;String</span><br><span class="hljs-comment">//  - String</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">takes_asref_str</span></span>&lt;S: <span class="hljs-built_in">AsRef</span>&lt;<span class="hljs-built_in">str</span>&gt;&gt;(s: S) &#123;<br>    <span class="hljs-keyword">let</span> s: &amp;<span class="hljs-built_in">str</span> = s.as_ref();<br>    <span class="hljs-comment">// use &amp;str</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">example</span></span>(slice: &amp;<span class="hljs-built_in">str</span>, borrow: &amp;<span class="hljs-built_in">String</span>, owned: <span class="hljs-built_in">String</span>) &#123;<br>    takes_str(slice);<br>    takes_str(borrow);<br>    takes_str(owned); <span class="hljs-comment">// ❌</span><br>    takes_asref_str(slice);<br>    takes_asref_str(borrow);<br>    takes_asref_str(owned); <span class="hljs-comment">// ✅</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>AsRef 可以返回类型内部私有数据的引用。通常这个私有数据被一个不可变类型所包裹</p><p> 例如标准库的String, 包裹了Vec<u8> 作为私有数据。内部的Vec<u8>不能被公开，因为如果这样的话，人们就会修改里面的字节并破坏String中有效的 UTF-8 编码。但是，暴露内部字节数组的一个不可变的只读引用是安全的，</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">String</span></span> &#123;<br>    vec: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;,<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-built_in">AsRef</span>&lt;[<span class="hljs-built_in">u8</span>]&gt; <span class="hljs-keyword">for</span> <span class="hljs-built_in">String</span>;<br></code></pre></td></tr></table></figure></li><li><p>AsRef用于语义相等的事物之间引用到引用的转换，</p><ol><li><p>一个反例</p><p> 下面是为任意类型实现AsRef</p><p> User 包含String&#x2F;u32， 但User不是String&#x2F;u32。对于这样的类型实现AsRef没有什么意义，</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">User</span></span> &#123;<br>    name: <span class="hljs-built_in">String</span>,<br>    email: <span class="hljs-built_in">String</span>,<br>    age: <span class="hljs-built_in">u32</span>,<br>    height: <span class="hljs-built_in">u32</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-built_in">AsRef</span>&lt;<span class="hljs-built_in">String</span>&gt; <span class="hljs-keyword">for</span> User &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">as_ref</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;<span class="hljs-built_in">String</span> &#123;、<br>        <span class="hljs-comment">//我们返回 name 还是 email?        </span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-built_in">AsRef</span>&lt;<span class="hljs-built_in">u32</span>&gt; <span class="hljs-keyword">for</span> User &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">as_ref</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;<span class="hljs-built_in">u32</span> &#123;<br>        <span class="hljs-comment">//我们返回 age 还是 height？</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>一个正确的例子</p><p> Moderator 是一个User，User可以做的事情，Moderator也应该可以做</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">User</span></span> &#123;<br>    name: <span class="hljs-built_in">String</span>,<br>    age: <span class="hljs-built_in">u32</span>,<br>&#125;<br><br><span class="hljs-comment">//不幸地是，标准库并没有提供一个generic blanket impl来避免这种重复的实现</span><br><span class="hljs-keyword">impl</span> <span class="hljs-built_in">AsRef</span>&lt;User&gt; <span class="hljs-keyword">for</span> User &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">as_ref</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;User &#123;<br>        <span class="hljs-keyword">self</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Privilege</span></span> &#123;<br>    BanUsers,<br>    EditPosts,<br>    DeletePosts,<br>&#125;<br><br><span class="hljs-comment">//尽管 Moderators 有一些特殊权限，它们仍然是普通的 User </span><br><span class="hljs-comment">//并且应该做相同的事情</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Moderator</span></span> &#123;<br>    user: User,<br>    privileges: <span class="hljs-built_in">Vec</span>&lt;Privilege&gt;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-built_in">AsRef</span>&lt;Moderator&gt; <span class="hljs-keyword">for</span> Moderator &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">as_ref</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;Moderator &#123;<br>        <span class="hljs-keyword">self</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-built_in">AsRef</span>&lt;User&gt; <span class="hljs-keyword">for</span> Moderator &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">as_ref</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;User &#123;<br>        &amp;<span class="hljs-keyword">self</span>.user<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//使用 User 和 Moderators （也是一种User）应该都是可以调用的</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">create_post</span></span>&lt;U: <span class="hljs-built_in">AsRef</span>&lt;User&gt;&gt;(u: U) &#123;<br>    <span class="hljs-keyword">let</span> user = u.as_ref();<br>    <span class="hljs-comment">// etc</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">example</span></span>(user: User, moderator: Moderator) &#123;<br>    create_post(&amp;user);<br>    create_post(&amp;moderator); <span class="hljs-comment">// ✅</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol></li></ol><h3 id="3-Borrow-x2F-BorrowMut"><a href="#3-Borrow-x2F-BorrowMut" class="headerlink" title="3. Borrow&#x2F;BorrowMut"></a>3. Borrow&#x2F;BorrowMut</h3><ol><li><p>定义</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Borrow</span></span>&lt;Borrowed&gt;<br><span class="hljs-keyword">where</span><br>    Borrowed: ?<span class="hljs-built_in">Sized</span>,<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">borrow</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;Borrowed;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">BorrowMut</span></span>&lt;Borrowed&gt;: Borrow&lt;Borrowed&gt;<br><span class="hljs-keyword">where</span><br>    Borrowed: ?<span class="hljs-built_in">Sized</span>,<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">borrow_mut</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; &amp;<span class="hljs-keyword">mut</span> Borrowed;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>作用</p><ol><li>最初的作用：使用&amp;str类型的值在HashSet、HashMap、BTreeSet和BTreeMap中查找String类型的 key。</li><li>我们可以把Borrow<T>和BorrowMut<T>看作更严格的AsRef<T>和AsMut<T>，它们返回的引用&amp;T与Self有等价性的Eq、Hash和Ord实现。</li></ol></li><li><p>例子</p><p> borrow&#x2F;borrow_mut 返回的引用 是满足Eq、Hash、Ord三个Trait的</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::borrow::Borrow;<br><span class="hljs-keyword">use</span> std::hash::Hasher;<br><span class="hljs-keyword">use</span> std::collections::hash_map::DefaultHasher;<br><span class="hljs-keyword">use</span> std::hash::Hash;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_hash</span></span>&lt;T: Hash&gt;(t: T) -&gt; <span class="hljs-built_in">u64</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> hasher = DefaultHasher::new();<br>    t.hash(&amp;<span class="hljs-keyword">mut</span> hasher);<br>    hasher.finish()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">asref_example</span></span>&lt;Owned, Ref&gt;(owned1: Owned, owned2: Owned)<br><span class="hljs-keyword">where</span><br>    Owned: <span class="hljs-built_in">Eq</span> + <span class="hljs-built_in">Ord</span> + Hash + <span class="hljs-built_in">AsRef</span>&lt;Ref&gt;,<br>    Ref: <span class="hljs-built_in">Eq</span> + <span class="hljs-built_in">Ord</span> + Hash<br>&#123;<br>    <span class="hljs-keyword">let</span> ref1: &amp;Ref = owned1.as_ref();<br>    <span class="hljs-keyword">let</span> ref2: &amp;Ref = owned2.as_ref();<br><br>    <span class="hljs-comment">// refs aren&#x27;t required to be equal if owned types are equal</span><br>    <span class="hljs-built_in">assert_eq!</span>(owned1 == owned2, ref1 == ref2); <span class="hljs-comment">// ❌</span><br><br>    <span class="hljs-keyword">let</span> owned1_hash = get_hash(&amp;owned1);<br>    <span class="hljs-keyword">let</span> owned2_hash = get_hash(&amp;owned2);<br>    <span class="hljs-keyword">let</span> ref1_hash = get_hash(&amp;ref1);<br>    <span class="hljs-keyword">let</span> ref2_hash = get_hash(&amp;ref2);<br><br>    <span class="hljs-comment">// ref hashes aren&#x27;t required to be equal if owned type hashes are equal</span><br>    <span class="hljs-built_in">assert_eq!</span>(owned1_hash == owned2_hash, ref1_hash == ref2_hash); <span class="hljs-comment">// ❌</span><br><br>    <span class="hljs-comment">// ref comparisons aren&#x27;t required to match owned type comparisons</span><br>    <span class="hljs-built_in">assert_eq!</span>(owned1.cmp(&amp;owned2), ref1.cmp(&amp;ref2)); <span class="hljs-comment">// ❌</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">borrow_example</span></span>&lt;Owned, Borrowed&gt;(owned1: Owned, owned2: Owned)<br><span class="hljs-keyword">where</span><br>    Owned: <span class="hljs-built_in">Eq</span> + <span class="hljs-built_in">Ord</span> + Hash + Borrow&lt;Borrowed&gt;,<br>    Borrowed: <span class="hljs-built_in">Eq</span> + <span class="hljs-built_in">Ord</span> + Hash<br>&#123;<br>    <span class="hljs-keyword">let</span> borrow1: &amp;Borrowed = owned1.borrow();<br>    <span class="hljs-keyword">let</span> borrow2: &amp;Borrowed = owned2.borrow();<br><br>    <span class="hljs-comment">// borrows are required to be equal if owned types are equal</span><br>    <span class="hljs-built_in">assert_eq!</span>(owned1 == owned2, borrow1 == borrow2); <span class="hljs-comment">// ✅</span><br><br>    <span class="hljs-keyword">let</span> owned1_hash = get_hash(&amp;owned1);<br>    <span class="hljs-keyword">let</span> owned2_hash = get_hash(&amp;owned2);<br>    <span class="hljs-keyword">let</span> borrow1_hash = get_hash(&amp;borrow1);<br>    <span class="hljs-keyword">let</span> borrow2_hash = get_hash(&amp;borrow2);<br><br>    <span class="hljs-comment">// borrow hashes are required to be equal if owned type hashes are equal</span><br>    <span class="hljs-built_in">assert_eq!</span>(owned1_hash == owned2_hash, borrow1_hash == borrow2_hash); <span class="hljs-comment">// ✅</span><br><br>    <span class="hljs-comment">// borrow comparisons are required to match owned type comparisons</span><br>    <span class="hljs-built_in">assert_eq!</span>(owned1.cmp(&amp;owned2), borrow1.cmp(&amp;borrow2)); <span class="hljs-comment">// ✅</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>特点</p><ol><li>这个Trait是为一个类型的引用类型准备的，很少由程序员手动实现引用类型的Trait</li><li><code>T:Borrorw&lt;T&gt;</code>已经为所有的类型T实现了，所以我们不需要手动地实现它；并且我们不需要创建一个U以用来<code>T:Borrow&lt;U&gt;</code></li></ol></li></ol><h3 id="4-ToOwned"><a href="#4-ToOwned" class="headerlink" title="4. ToOwned"></a>4. ToOwned</h3><ol><li><p>定义</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">ToOwned</span></span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Owned</span></span>: Borrow&lt;<span class="hljs-keyword">Self</span>&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">to_owned</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; Self::Owned;<br><br>    <span class="hljs-comment">// 提供默认实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">clone_into</span></span>(&amp;<span class="hljs-keyword">self</span>, target: &amp;<span class="hljs-keyword">mut</span> Self::Owned);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>作用</p><ol><li>ToOwned是Clone的一个更为通用的版本。Clone允许我们获取一个&amp;T并把它转为一个T，但是ToOwned允许我们拿到一个&amp;Borrowed并把它转为一个Owned，其中Owned: Borrow<Borrowed>。<ol><li>换句话说，我们不能从一个&amp;str克隆一个String，或者从一个&amp;Path克隆一个PathBuf，或者从一个&amp;OsStr克隆一个OsString，因为clone方法签名不支持这种跨类型的克隆，这就是ToOwned产生的原因。</li></ol></li></ol></li></ol><h2 id="八、Iteration-Traits"><a href="#八、Iteration-Traits" class="headerlink" title="八、Iteration Traits"></a>八、<strong><strong>Iteration Traits</strong></strong></h2><h3 id="1-Iterator"><a href="#1-Iterator" class="headerlink" title="1. Iterator"></a>1. Iterator</h3><ol><li><p>定义</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Iterator</span></span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Item</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">next</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;Self::Item&gt;;<br><br>    <span class="hljs-comment">// provided default impls</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">size_hint</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; (<span class="hljs-built_in">usize</span>, <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">usize</span>&gt;);<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">count</span></span>(<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">usize</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">last</span></span>(<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;Self::Item&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">advance_by</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, n: <span class="hljs-built_in">usize</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;(), <span class="hljs-built_in">usize</span>&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">nth</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, n: <span class="hljs-built_in">usize</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;Self::Item&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">step_by</span></span>(<span class="hljs-keyword">self</span>, step: <span class="hljs-built_in">usize</span>) -&gt; StepBy&lt;<span class="hljs-keyword">Self</span>&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">chain</span></span>&lt;U&gt;(<br>        <span class="hljs-keyword">self</span>, <br>        other: U<br>    ) -&gt; Chain&lt;<span class="hljs-keyword">Self</span>, &lt;U <span class="hljs-keyword">as</span> <span class="hljs-built_in">IntoIterator</span>&gt;::IntoIter&gt;<br>    <span class="hljs-keyword">where</span><br>        U: <span class="hljs-built_in">IntoIterator</span>&lt;Item = Self::Item&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">zip</span></span>&lt;U&gt;(<span class="hljs-keyword">self</span>, other: U) -&gt; Zip&lt;<span class="hljs-keyword">Self</span>, &lt;U <span class="hljs-keyword">as</span> <span class="hljs-built_in">IntoIterator</span>&gt;::IntoIter&gt;<br>    <span class="hljs-keyword">where</span><br>        U: <span class="hljs-built_in">IntoIterator</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">map</span></span>&lt;B, F&gt;(<span class="hljs-keyword">self</span>, f: F) -&gt; Map&lt;<span class="hljs-keyword">Self</span>, F&gt;<br>    <span class="hljs-keyword">where</span><br>        F: <span class="hljs-built_in">FnMut</span>(Self::Item) -&gt; B;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">for_each</span></span>&lt;F&gt;(<span class="hljs-keyword">self</span>, f: F)<br>    <span class="hljs-keyword">where</span><br>        F: <span class="hljs-built_in">FnMut</span>(Self::Item);<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">filter</span></span>&lt;P&gt;(<span class="hljs-keyword">self</span>, predicate: P) -&gt; Filter&lt;<span class="hljs-keyword">Self</span>, P&gt;<br>    <span class="hljs-keyword">where</span><br>        P: <span class="hljs-built_in">FnMut</span>(&amp;Self::Item) -&gt; <span class="hljs-built_in">bool</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">filter_map</span></span>&lt;B, F&gt;(<span class="hljs-keyword">self</span>, f: F) -&gt; FilterMap&lt;<span class="hljs-keyword">Self</span>, F&gt;<br>    <span class="hljs-keyword">where</span><br>        F: <span class="hljs-built_in">FnMut</span>(Self::Item) -&gt; <span class="hljs-built_in">Option</span>&lt;B&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">enumerate</span></span>(<span class="hljs-keyword">self</span>) -&gt; Enumerate&lt;<span class="hljs-keyword">Self</span>&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">peekable</span></span>(<span class="hljs-keyword">self</span>) -&gt; Peekable&lt;<span class="hljs-keyword">Self</span>&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">skip_while</span></span>&lt;P&gt;(<span class="hljs-keyword">self</span>, predicate: P) -&gt; SkipWhile&lt;<span class="hljs-keyword">Self</span>, P&gt;<br>    <span class="hljs-keyword">where</span><br>        P: <span class="hljs-built_in">FnMut</span>(&amp;Self::Item) -&gt; <span class="hljs-built_in">bool</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">take_while</span></span>&lt;P&gt;(<span class="hljs-keyword">self</span>, predicate: P) -&gt; TakeWhile&lt;<span class="hljs-keyword">Self</span>, P&gt;<br>    <span class="hljs-keyword">where</span><br>        P: <span class="hljs-built_in">FnMut</span>(&amp;Self::Item) -&gt; <span class="hljs-built_in">bool</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">map_while</span></span>&lt;B, P&gt;(<span class="hljs-keyword">self</span>, predicate: P) -&gt; MapWhile&lt;<span class="hljs-keyword">Self</span>, P&gt;<br>    <span class="hljs-keyword">where</span><br>        P: <span class="hljs-built_in">FnMut</span>(Self::Item) -&gt; <span class="hljs-built_in">Option</span>&lt;B&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">skip</span></span>(<span class="hljs-keyword">self</span>, n: <span class="hljs-built_in">usize</span>) -&gt; Skip&lt;<span class="hljs-keyword">Self</span>&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">take</span></span>(<span class="hljs-keyword">self</span>, n: <span class="hljs-built_in">usize</span>) -&gt; Take&lt;<span class="hljs-keyword">Self</span>&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">scan</span></span>&lt;St, B, F&gt;(<span class="hljs-keyword">self</span>, initial_state: St, f: F) -&gt; Scan&lt;<span class="hljs-keyword">Self</span>, St, F&gt;<br>    <span class="hljs-keyword">where</span><br>        F: <span class="hljs-built_in">FnMut</span>(&amp;<span class="hljs-keyword">mut</span> St, Self::Item) -&gt; <span class="hljs-built_in">Option</span>&lt;B&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">flat_map</span></span>&lt;U, F&gt;(<span class="hljs-keyword">self</span>, f: F) -&gt; FlatMap&lt;<span class="hljs-keyword">Self</span>, U, F&gt;<br>    <span class="hljs-keyword">where</span><br>        F: <span class="hljs-built_in">FnMut</span>(Self::Item) -&gt; U,<br>        U: <span class="hljs-built_in">IntoIterator</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">flatten</span></span>(<span class="hljs-keyword">self</span>) -&gt; Flatten&lt;<span class="hljs-keyword">Self</span>&gt;<br>    <span class="hljs-keyword">where</span><br>        Self::Item: <span class="hljs-built_in">IntoIterator</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">fuse</span></span>(<span class="hljs-keyword">self</span>) -&gt; Fuse&lt;<span class="hljs-keyword">Self</span>&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">inspect</span></span>&lt;F&gt;(<span class="hljs-keyword">self</span>, f: F) -&gt; Inspect&lt;<span class="hljs-keyword">Self</span>, F&gt;<br>    <span class="hljs-keyword">where</span><br>        F: <span class="hljs-built_in">FnMut</span>(&amp;Self::Item);<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">by_ref</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">Self</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">collect</span></span>&lt;B&gt;(<span class="hljs-keyword">self</span>) -&gt; B<br>    <span class="hljs-keyword">where</span><br>        B: FromIterator&lt;Self::Item&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">partition</span></span>&lt;B, F&gt;(<span class="hljs-keyword">self</span>, f: F) -&gt; (B, B)<br>    <span class="hljs-keyword">where</span><br>        F: <span class="hljs-built_in">FnMut</span>(&amp;Self::Item) -&gt; <span class="hljs-built_in">bool</span>,<br>        B: <span class="hljs-built_in">Default</span> + <span class="hljs-built_in">Extend</span>&lt;Self::Item&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">partition_in_place</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>, T, P&gt;(<span class="hljs-keyword">self</span>, predicate: P) -&gt; <span class="hljs-built_in">usize</span><br>    <span class="hljs-keyword">where</span><br>        <span class="hljs-keyword">Self</span>: <span class="hljs-built_in">DoubleEndedIterator</span>&lt;Item = &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> T&gt;,<br>        T: <span class="hljs-symbol">&#x27;a</span>,<br>        P: <span class="hljs-built_in">FnMut</span>(&amp;T) -&gt; <span class="hljs-built_in">bool</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">is_partitioned</span></span>&lt;P&gt;(<span class="hljs-keyword">self</span>, predicate: P) -&gt; <span class="hljs-built_in">bool</span><br>    <span class="hljs-keyword">where</span><br>        P: <span class="hljs-built_in">FnMut</span>(Self::Item) -&gt; <span class="hljs-built_in">bool</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">try_fold</span></span>&lt;B, F, R&gt;(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, init: B, f: F) -&gt; R<br>    <span class="hljs-keyword">where</span><br>        F: <span class="hljs-built_in">FnMut</span>(B, Self::Item) -&gt; R,<br>        R: Try&lt;<span class="hljs-literal">Ok</span> = B&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">try_for_each</span></span>&lt;F, R&gt;(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, f: F) -&gt; R<br>    <span class="hljs-keyword">where</span><br>        F: <span class="hljs-built_in">FnMut</span>(Self::Item) -&gt; R,<br>        R: Try&lt;<span class="hljs-literal">Ok</span> = ()&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">fold</span></span>&lt;B, F&gt;(<span class="hljs-keyword">self</span>, init: B, f: F) -&gt; B<br>    <span class="hljs-keyword">where</span><br>        F: <span class="hljs-built_in">FnMut</span>(B, Self::Item) -&gt; B;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">fold_first</span></span>&lt;F&gt;(<span class="hljs-keyword">self</span>, f: F) -&gt; <span class="hljs-built_in">Option</span>&lt;Self::Item&gt;<br>    <span class="hljs-keyword">where</span><br>        F: <span class="hljs-built_in">FnMut</span>(Self::Item, Self::Item) -&gt; Self::Item;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">all</span></span>&lt;F&gt;(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, f: F) -&gt; <span class="hljs-built_in">bool</span><br>    <span class="hljs-keyword">where</span><br>        F: <span class="hljs-built_in">FnMut</span>(Self::Item) -&gt; <span class="hljs-built_in">bool</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">any</span></span>&lt;F&gt;(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, f: F) -&gt; <span class="hljs-built_in">bool</span><br>    <span class="hljs-keyword">where</span><br>        F: <span class="hljs-built_in">FnMut</span>(Self::Item) -&gt; <span class="hljs-built_in">bool</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">find</span></span>&lt;P&gt;(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, predicate: P) -&gt; <span class="hljs-built_in">Option</span>&lt;Self::Item&gt;<br>    <span class="hljs-keyword">where</span><br>        P: <span class="hljs-built_in">FnMut</span>(&amp;Self::Item) -&gt; <span class="hljs-built_in">bool</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">find_map</span></span>&lt;B, F&gt;(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, f: F) -&gt; <span class="hljs-built_in">Option</span>&lt;B&gt;<br>    <span class="hljs-keyword">where</span><br>        F: <span class="hljs-built_in">FnMut</span>(Self::Item) -&gt; <span class="hljs-built_in">Option</span>&lt;B&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">try_find</span></span>&lt;F, R&gt;(<br>        &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, <br>        f: F<br>    ) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">Option</span>&lt;Self::Item&gt;, &lt;R <span class="hljs-keyword">as</span> Try&gt;::Error&gt;<br>    <span class="hljs-keyword">where</span><br>        F: <span class="hljs-built_in">FnMut</span>(&amp;Self::Item) -&gt; R,<br>        R: Try&lt;<span class="hljs-literal">Ok</span> = <span class="hljs-built_in">bool</span>&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">position</span></span>&lt;P&gt;(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, predicate: P) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">usize</span>&gt;<br>    <span class="hljs-keyword">where</span><br>        P: <span class="hljs-built_in">FnMut</span>(Self::Item) -&gt; <span class="hljs-built_in">bool</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">rposition</span></span>&lt;P&gt;(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, predicate: P) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">usize</span>&gt;<br>    <span class="hljs-keyword">where</span><br>        <span class="hljs-keyword">Self</span>: <span class="hljs-built_in">ExactSizeIterator</span> + <span class="hljs-built_in">DoubleEndedIterator</span>,<br>        P: <span class="hljs-built_in">FnMut</span>(Self::Item) -&gt; <span class="hljs-built_in">bool</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">max</span></span>(<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;Self::Item&gt;<br>    <span class="hljs-keyword">where</span><br>        Self::Item: <span class="hljs-built_in">Ord</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">min</span></span>(<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;Self::Item&gt;<br>    <span class="hljs-keyword">where</span><br>        Self::Item: <span class="hljs-built_in">Ord</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">max_by_key</span></span>&lt;B, F&gt;(<span class="hljs-keyword">self</span>, f: F) -&gt; <span class="hljs-built_in">Option</span>&lt;Self::Item&gt;<br>    <span class="hljs-keyword">where</span><br>        F: <span class="hljs-built_in">FnMut</span>(&amp;Self::Item) -&gt; B,<br>        B: <span class="hljs-built_in">Ord</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">max_by</span></span>&lt;F&gt;(<span class="hljs-keyword">self</span>, compare: F) -&gt; <span class="hljs-built_in">Option</span>&lt;Self::Item&gt;<br>    <span class="hljs-keyword">where</span><br>        F: <span class="hljs-built_in">FnMut</span>(&amp;Self::Item, &amp;Self::Item) -&gt; Ordering;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">min_by_key</span></span>&lt;B, F&gt;(<span class="hljs-keyword">self</span>, f: F) -&gt; <span class="hljs-built_in">Option</span>&lt;Self::Item&gt;<br>    <span class="hljs-keyword">where</span><br>        F: <span class="hljs-built_in">FnMut</span>(&amp;Self::Item) -&gt; B,<br>        B: <span class="hljs-built_in">Ord</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">min_by</span></span>&lt;F&gt;(<span class="hljs-keyword">self</span>, compare: F) -&gt; <span class="hljs-built_in">Option</span>&lt;Self::Item&gt;<br>    <span class="hljs-keyword">where</span><br>        F: <span class="hljs-built_in">FnMut</span>(&amp;Self::Item, &amp;Self::Item) -&gt; Ordering;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">rev</span></span>(<span class="hljs-keyword">self</span>) -&gt; Rev&lt;<span class="hljs-keyword">Self</span>&gt;<br>    <span class="hljs-keyword">where</span><br>        <span class="hljs-keyword">Self</span>: <span class="hljs-built_in">DoubleEndedIterator</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">unzip</span></span>&lt;A, B, FromA, FromB&gt;(<span class="hljs-keyword">self</span>) -&gt; (FromA, FromB)<br>    <span class="hljs-keyword">where</span><br>        <span class="hljs-keyword">Self</span>: <span class="hljs-built_in">Iterator</span>&lt;Item = (A, B)&gt;,<br>        FromA: <span class="hljs-built_in">Default</span> + <span class="hljs-built_in">Extend</span>&lt;A&gt;,<br>        FromB: <span class="hljs-built_in">Default</span> + <span class="hljs-built_in">Extend</span>&lt;B&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">copied</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt;(<span class="hljs-keyword">self</span>) -&gt; Copied&lt;<span class="hljs-keyword">Self</span>&gt;<br>    <span class="hljs-keyword">where</span><br>        <span class="hljs-keyword">Self</span>: <span class="hljs-built_in">Iterator</span>&lt;Item = &amp;<span class="hljs-symbol">&#x27;a</span> T&gt;,<br>        T: <span class="hljs-symbol">&#x27;a</span> + <span class="hljs-built_in">Copy</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">cloned</span></span>&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt;(<span class="hljs-keyword">self</span>) -&gt; Cloned&lt;<span class="hljs-keyword">Self</span>&gt;<br>    <span class="hljs-keyword">where</span><br>        <span class="hljs-keyword">Self</span>: <span class="hljs-built_in">Iterator</span>&lt;Item = &amp;<span class="hljs-symbol">&#x27;a</span> T&gt;,<br>        T: <span class="hljs-symbol">&#x27;a</span> + <span class="hljs-built_in">Clone</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">cycle</span></span>(<span class="hljs-keyword">self</span>) -&gt; Cycle&lt;<span class="hljs-keyword">Self</span>&gt;<br>    <span class="hljs-keyword">where</span><br>        <span class="hljs-keyword">Self</span>: <span class="hljs-built_in">Clone</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">sum</span></span>&lt;S&gt;(<span class="hljs-keyword">self</span>) -&gt; S<br>    <span class="hljs-keyword">where</span><br>        S: Sum&lt;Self::Item&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">product</span></span>&lt;P&gt;(<span class="hljs-keyword">self</span>) -&gt; P<br>    <span class="hljs-keyword">where</span><br>        P: Product&lt;Self::Item&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">cmp</span></span>&lt;I&gt;(<span class="hljs-keyword">self</span>, other: I) -&gt; Ordering<br>    <span class="hljs-keyword">where</span><br>        I: <span class="hljs-built_in">IntoIterator</span>&lt;Item = Self::Item&gt;,<br>        Self::Item: <span class="hljs-built_in">Ord</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">cmp_by</span></span>&lt;I, F&gt;(<span class="hljs-keyword">self</span>, other: I, cmp: F) -&gt; Ordering<br>    <span class="hljs-keyword">where</span><br>        F: <span class="hljs-built_in">FnMut</span>(Self::Item, &lt;I <span class="hljs-keyword">as</span> <span class="hljs-built_in">IntoIterator</span>&gt;::Item) -&gt; Ordering,<br>        I: <span class="hljs-built_in">IntoIterator</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">partial_cmp</span></span>&lt;I&gt;(<span class="hljs-keyword">self</span>, other: I) -&gt; <span class="hljs-built_in">Option</span>&lt;Ordering&gt;<br>    <span class="hljs-keyword">where</span><br>        I: <span class="hljs-built_in">IntoIterator</span>,<br>        Self::Item: <span class="hljs-built_in">PartialOrd</span>&lt;&lt;I <span class="hljs-keyword">as</span> <span class="hljs-built_in">IntoIterator</span>&gt;::Item&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">partial_cmp_by</span></span>&lt;I, F&gt;(<br>        <span class="hljs-keyword">self</span>, <br>        other: I, <br>        partial_cmp: F<br>    ) -&gt; <span class="hljs-built_in">Option</span>&lt;Ordering&gt;<br>    <span class="hljs-keyword">where</span><br>        F: <span class="hljs-built_in">FnMut</span>(Self::Item, &lt;I <span class="hljs-keyword">as</span> <span class="hljs-built_in">IntoIterator</span>&gt;::Item) -&gt; <span class="hljs-built_in">Option</span>&lt;Ordering&gt;,<br>        I: <span class="hljs-built_in">IntoIterator</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">eq</span></span>&lt;I&gt;(<span class="hljs-keyword">self</span>, other: I) -&gt; <span class="hljs-built_in">bool</span><br>    <span class="hljs-keyword">where</span><br>        I: <span class="hljs-built_in">IntoIterator</span>,<br>        Self::Item: <span class="hljs-built_in">PartialEq</span>&lt;&lt;I <span class="hljs-keyword">as</span> <span class="hljs-built_in">IntoIterator</span>&gt;::Item&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">eq_by</span></span>&lt;I, F&gt;(<span class="hljs-keyword">self</span>, other: I, eq: F) -&gt; <span class="hljs-built_in">bool</span><br>    <span class="hljs-keyword">where</span><br>        F: <span class="hljs-built_in">FnMut</span>(Self::Item, &lt;I <span class="hljs-keyword">as</span> <span class="hljs-built_in">IntoIterator</span>&gt;::Item) -&gt; <span class="hljs-built_in">bool</span>,<br>        I: <span class="hljs-built_in">IntoIterator</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">ne</span></span>&lt;I&gt;(<span class="hljs-keyword">self</span>, other: I) -&gt; <span class="hljs-built_in">bool</span><br>    <span class="hljs-keyword">where</span><br>        I: <span class="hljs-built_in">IntoIterator</span>,<br>        Self::Item: <span class="hljs-built_in">PartialEq</span>&lt;&lt;I <span class="hljs-keyword">as</span> <span class="hljs-built_in">IntoIterator</span>&gt;::Item&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">lt</span></span>&lt;I&gt;(<span class="hljs-keyword">self</span>, other: I) -&gt; <span class="hljs-built_in">bool</span><br>    <span class="hljs-keyword">where</span><br>        I: <span class="hljs-built_in">IntoIterator</span>,<br>        Self::Item: <span class="hljs-built_in">PartialOrd</span>&lt;&lt;I <span class="hljs-keyword">as</span> <span class="hljs-built_in">IntoIterator</span>&gt;::Item&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">le</span></span>&lt;I&gt;(<span class="hljs-keyword">self</span>, other: I) -&gt; <span class="hljs-built_in">bool</span><br>    <span class="hljs-keyword">where</span><br>        I: <span class="hljs-built_in">IntoIterator</span>,<br>        Self::Item: <span class="hljs-built_in">PartialOrd</span>&lt;&lt;I <span class="hljs-keyword">as</span> <span class="hljs-built_in">IntoIterator</span>&gt;::Item&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">gt</span></span>&lt;I&gt;(<span class="hljs-keyword">self</span>, other: I) -&gt; <span class="hljs-built_in">bool</span><br>    <span class="hljs-keyword">where</span><br>        I: <span class="hljs-built_in">IntoIterator</span>,<br>        Self::Item: <span class="hljs-built_in">PartialOrd</span>&lt;&lt;I <span class="hljs-keyword">as</span> <span class="hljs-built_in">IntoIterator</span>&gt;::Item&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">ge</span></span>&lt;I&gt;(<span class="hljs-keyword">self</span>, other: I) -&gt; <span class="hljs-built_in">bool</span><br>    <span class="hljs-keyword">where</span><br>        I: <span class="hljs-built_in">IntoIterator</span>,<br>        Self::Item: <span class="hljs-built_in">PartialOrd</span>&lt;&lt;I <span class="hljs-keyword">as</span> <span class="hljs-built_in">IntoIterator</span>&gt;::Item&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">is_sorted</span></span>(<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">bool</span><br>    <span class="hljs-keyword">where</span><br>        Self::Item: <span class="hljs-built_in">PartialOrd</span>&lt;Self::Item&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">is_sorted_by</span></span>&lt;F&gt;(<span class="hljs-keyword">self</span>, compare: F) -&gt; <span class="hljs-built_in">bool</span><br>    <span class="hljs-keyword">where</span><br>        F: <span class="hljs-built_in">FnMut</span>(&amp;Self::Item, &amp;Self::Item) -&gt; <span class="hljs-built_in">Option</span>&lt;Ordering&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">is_sorted_by_key</span></span>&lt;F, K&gt;(<span class="hljs-keyword">self</span>, f: F) -&gt; <span class="hljs-built_in">bool</span><br>    <span class="hljs-keyword">where</span><br>        F: <span class="hljs-built_in">FnMut</span>(Self::Item) -&gt; K,<br>        K: <span class="hljs-built_in">PartialOrd</span>&lt;K&gt;;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>实现</p><ol><li><p>Iterator&lt;Item &#x3D; T&gt;类型可以被迭代并产生T类型。没有IteratorMut trait。每个Iterator实现可以指定它返回的是不可变引用、可变引用还是拥有通过Item关联类型的值。</p><table><thead><tr><th>Vec<T> method</th><th>Returns</th></tr></thead><tbody><tr><td>.iter()</td><td>Iterator&lt;Item &#x3D; &amp;T&gt;</td></tr><tr><td>.iter_mut()</td><td>Iterator&lt;Item &#x3D; &amp;mut T&gt;</td></tr><tr><td>.into_iter()</td><td>Iterator&lt;Item &#x3D; T&gt;</td></tr><tr><td></td><td></td></tr></tbody></table></li><li><p>大多数类型没有它们自己的迭代器。如果一个类型是可迭代的，我们几乎总是实现自定义的迭代器类型来迭代它，而不是让它自己迭代。</p><p> 可以使用Vec 的iter方法对自己的类型迭代</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyType</span></span> &#123;<br>    items: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">String</span>&gt;<br>&#125;<br><br><span class="hljs-keyword">impl</span> MyType &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">iter</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-keyword">impl</span> <span class="hljs-built_in">Iterator</span>&lt;Item = &amp;<span class="hljs-built_in">String</span>&gt; &#123;<br>        <span class="hljs-keyword">self</span>.items.iter()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>It says that any mutable reference to an iterator is also an iterator. This is useful to know because it allows us to use iterator methods with self receivers as if they had &amp;mut self receivers.</p><ol><li>这里是说Iterator定义的方法，接受self的方法和接受&amp;mut self的方法是一样的</li></ol></li><li><p>如果我们想对一个超过三项的迭代器进行处理的函数，函数要先消耗三个元素，再进行处理</p><ol><li><p>这是一个错误范例</p><p> take方法接受self对象，换句话说，它消耗了iter这个实例，接下来再调用iter会报错</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">example</span></span>&lt;I: <span class="hljs-built_in">Iterator</span>&lt;Item = <span class="hljs-built_in">i32</span>&gt;&gt;(<span class="hljs-keyword">mut</span> iter: I) &#123;<br>    <span class="hljs-keyword">let</span> first3: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">i32</span>&gt; = iter.take(<span class="hljs-number">3</span>).collect();<br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> iter &#123; <span class="hljs-comment">// ❌ iter consumed in line above</span><br>        <span class="hljs-comment">// process remaining items</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>下面两种方法可以达到目的</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">example</span></span>&lt;I: <span class="hljs-built_in">Iterator</span>&lt;Item = <span class="hljs-built_in">i32</span>&gt;&gt;(<span class="hljs-keyword">mut</span> iter: I) &#123;<br>    <span class="hljs-keyword">let</span> first3: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">i32</span>&gt; = <span class="hljs-built_in">vec!</span>[<br>        iter.next().unwrap(),<br>        iter.next().unwrap(),<br>        iter.next().unwrap(),<br>    ];<br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> iter &#123; <span class="hljs-comment">// ✅</span><br>        <span class="hljs-comment">// process remaining items</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">example</span></span>&lt;I: <span class="hljs-built_in">Iterator</span>&lt;Item = <span class="hljs-built_in">i32</span>&gt;&gt;(<span class="hljs-keyword">mut</span> iter: I) &#123;<br>    <span class="hljs-keyword">let</span> first3: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">i32</span>&gt; = iter.by_ref().take(<span class="hljs-number">3</span>).collect();<br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> iter &#123; <span class="hljs-comment">// ✅</span><br>        <span class="hljs-comment">// process remaining items</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol></li></ol><h3 id="2-IntoIter"><a href="#2-IntoIter" class="headerlink" title="2. IntoIter"></a>2. IntoIter</h3><ol><li><p>定义</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">IntoIterator</span></span> <br><span class="hljs-keyword">where</span><br>    &lt;Self::IntoIter <span class="hljs-keyword">as</span> <span class="hljs-built_in">Iterator</span>&gt;::Item == Self::Item, <br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Item</span></span>;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">IntoIter</span></span>: <span class="hljs-built_in">Iterator</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">into_iter</span></span>(<span class="hljs-keyword">self</span>) -&gt; Self::IntoIter;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>作用</p><p> 让类型T转换为迭代器类型，对于不可变引用、可变引用也如此</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// vec = Vec&lt;T&gt;</span><br><span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> vec &#123;&#125; <span class="hljs-comment">// v = T</span><br><br><span class="hljs-comment">// above line desugared</span><br><span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> vec.into_iter() &#123;&#125;<br><br><span class="hljs-comment">// vec = Vec&lt;T&gt;</span><br><span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> &amp;vec &#123;&#125; <span class="hljs-comment">// v = &amp;T</span><br><br><span class="hljs-comment">// above example desugared</span><br><span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> (&amp;vec).into_iter() &#123;&#125;<br><br><span class="hljs-comment">// vec = Vec&lt;T&gt;</span><br><span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">mut</span> vec &#123;&#125; <span class="hljs-comment">// v = &amp;mut T</span><br><br><span class="hljs-comment">// above example desugared</span><br><span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> (&amp;<span class="hljs-keyword">mut</span> vec).into_iter() &#123;&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-FromIterator"><a href="#3-FromIterator" class="headerlink" title="3. FromIterator"></a>3. FromIterator</h3><ol><li><p>定义</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">FromIterator</span></span>&lt;A&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">from_iter</span></span>&lt;T&gt;(iter: T) -&gt; <span class="hljs-keyword">Self</span><br>    <span class="hljs-keyword">where</span><br>        T: <span class="hljs-built_in">IntoIterator</span>&lt;Item = A&gt;;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>作用</p><p> 从迭代器类型转换为类型T</p><p> 比如collect方法</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">collect</span></span>&lt;B&gt;(<span class="hljs-keyword">self</span>) -&gt; B<br><span class="hljs-keyword">where</span><br>    B: FromIterator&lt;Self::Item&gt;;<br></code></pre></td></tr></table></figure></li><li><p>例子</p><p> collect 方法“收集”一个Iterator&lt;Item &#x3D; char&gt; 到 String:</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">filter_letters</span></span>(string: &amp;<span class="hljs-built_in">str</span>) -&gt; <span class="hljs-built_in">String</span> &#123;<br>    string.chars().filter(|c| c.is_alphabetic()).collect()<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="4-标准库类型靠迭代器相互转换的例子"><a href="#4-标准库类型靠迭代器相互转换的例子" class="headerlink" title="4. 标准库类型靠迭代器相互转换的例子"></a>4. 标准库类型靠迭代器相互转换的例子</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::&#123;BTreeSet, HashMap, HashSet, LinkedList&#125;;<br><br><span class="hljs-comment">// String -&gt; HashSet&lt;char&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">unique_chars</span></span>(string: &amp;<span class="hljs-built_in">str</span>) -&gt; HashSet&lt;<span class="hljs-built_in">char</span>&gt; &#123;<br>    string.chars().collect()<br>&#125;<br><br><span class="hljs-comment">// Vec&lt;T&gt; -&gt; BTreeSet&lt;T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">ordered_unique_items</span></span>&lt;T: <span class="hljs-built_in">Ord</span>&gt;(vec: <span class="hljs-built_in">Vec</span>&lt;T&gt;) -&gt; BTreeSet&lt;T&gt; &#123;<br>    vec.into_iter().collect()<br>&#125;<br><br><span class="hljs-comment">// HashMap&lt;K, V&gt; -&gt; LinkedList&lt;(K, V)&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">entry_list</span></span>&lt;K, V&gt;(map: HashMap&lt;K, V&gt;) -&gt; LinkedList&lt;(K, V)&gt; &#123;<br>    map.into_iter().collect()<br>&#125;<br><br><span class="hljs-comment">// and countless more possible examples</span><br></code></pre></td></tr></table></figure><h2 id="九、IO-Trait"><a href="#九、IO-Trait" class="headerlink" title="九、IO Trait"></a>九、IO Trait</h2><h3 id="1-Read-x2F-Write"><a href="#1-Read-x2F-Write" class="headerlink" title="1. Read&#x2F;Write"></a>1. Read&#x2F;Write</h3><ol><li><p>定义</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Read</span></span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">read</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, buf: &amp;<span class="hljs-keyword">mut</span> [<span class="hljs-built_in">u8</span>]) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">usize</span>&gt;;<br><br>    <span class="hljs-comment">// provided default impls</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">read_vectored</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, bufs: &amp;<span class="hljs-keyword">mut</span> [IoSliceMut&lt;<span class="hljs-symbol">&#x27;_</span>&gt;]) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">usize</span>&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">is_read_vectored</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">bool</span>;<br>    <span class="hljs-keyword">unsafe</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">initializer</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; Initializer;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">read_to_end</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, buf: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">usize</span>&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">read_to_string</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, buf: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">String</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">usize</span>&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">read_exact</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, buf: &amp;<span class="hljs-keyword">mut</span> [<span class="hljs-built_in">u8</span>]) -&gt; <span class="hljs-built_in">Result</span>&lt;()&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">by_ref</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">Self</span><br>    <span class="hljs-keyword">where</span><br>        <span class="hljs-keyword">Self</span>: <span class="hljs-built_in">Sized</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">bytes</span></span>(<span class="hljs-keyword">self</span>) -&gt; Bytes&lt;<span class="hljs-keyword">Self</span>&gt;<br>    <span class="hljs-keyword">where</span><br>        <span class="hljs-keyword">Self</span>: <span class="hljs-built_in">Sized</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">chain</span></span>&lt;R: Read&gt;(<span class="hljs-keyword">self</span>, next: R) -&gt; Chain&lt;<span class="hljs-keyword">Self</span>, R&gt;<br>    <span class="hljs-keyword">where</span><br>        <span class="hljs-keyword">Self</span>: <span class="hljs-built_in">Sized</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">take</span></span>(<span class="hljs-keyword">self</span>, limit: <span class="hljs-built_in">u64</span>) -&gt; Take&lt;<span class="hljs-keyword">Self</span>&gt;<br>    <span class="hljs-keyword">where</span><br>        <span class="hljs-keyword">Self</span>: <span class="hljs-built_in">Sized</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Write</span></span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">write</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, buf: &amp;[<span class="hljs-built_in">u8</span>]) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">usize</span>&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">flush</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;()&gt;;<br><br>    <span class="hljs-comment">// provided default impls</span><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">write_vectored</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, bufs: &amp;[IoSlice&lt;<span class="hljs-symbol">&#x27;_</span>&gt;]) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">usize</span>&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">is_write_vectored</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">bool</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">write_all</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, buf: &amp;[<span class="hljs-built_in">u8</span>]) -&gt; <span class="hljs-built_in">Result</span>&lt;()&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">write_all_vectored</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, bufs: &amp;<span class="hljs-keyword">mut</span> [IoSlice&lt;<span class="hljs-symbol">&#x27;_</span>&gt;]) -&gt; <span class="hljs-built_in">Result</span>&lt;()&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">write_fmt</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, fmt: Arguments&lt;<span class="hljs-symbol">&#x27;_</span>&gt;) -&gt; <span class="hljs-built_in">Result</span>&lt;()&gt;;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">by_ref</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">Self</span><br>    <span class="hljs-keyword">where</span><br>        <span class="hljs-keyword">Self</span>: <span class="hljs-built_in">Sized</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>实现</p><ol><li><p>标准库同样提供了泛型覆盖实现</p><p> Read类型的任何可变引用也都是Read，Write同理</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;R: Read + ?<span class="hljs-built_in">Sized</span>&gt; Read <span class="hljs-keyword">for</span> &amp;<span class="hljs-keyword">mut</span> R;<br><span class="hljs-keyword">impl</span>&lt;W: Write + ?<span class="hljs-built_in">Sized</span>&gt; Write <span class="hljs-keyword">for</span> &amp;<span class="hljs-keyword">mut</span> W;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>例子</p><p> &amp;[u8] 实现了Read，Vec<u8>实现了Write</p><p> 因此我们可以对我们的文件处理函数进行简单的单元测试，通过使用String转换为&amp;[u8]以及从Vec<u8> 转换为String：</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::path::Path;<br><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">use</span> std::io::Read;<br><span class="hljs-keyword">use</span> std::io::Write;<br><span class="hljs-keyword">use</span> std::io;<br><br><span class="hljs-comment">// function we want to test</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">uppercase</span></span>&lt;R: Read, W: Write&gt;(<span class="hljs-keyword">mut</span> read: R, <span class="hljs-keyword">mut</span> write: W) -&gt; <span class="hljs-built_in">Result</span>&lt;(), io::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> buffer = <span class="hljs-built_in">String</span>::new();<br>    read.read_to_string(&amp;<span class="hljs-keyword">mut</span> buffer)?;<br>    <span class="hljs-keyword">let</span> uppercase = buffer.to_uppercase();<br>    write.write_all(uppercase.as_bytes())?;<br>    write.flush()?;<br>    <span class="hljs-literal">Ok</span>(())<br>&#125;<br><br><span class="hljs-comment">// in actual program we&#x27;d pass Files</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">example</span></span>(in_path: &amp;Path, out_path: &amp;Path) -&gt; <span class="hljs-built_in">Result</span>&lt;(), io::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> in_file = File::open(in_path)?;<br>    <span class="hljs-keyword">let</span> out_file = File::open(out_path)?;<br>    uppercase(in_file, out_file)<br>&#125;<br><br><span class="hljs-comment">// however in unit tests we can use Strings!</span><br><span class="hljs-meta">#[test]</span> <span class="hljs-comment">// ✅</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">example_test</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> in_file: <span class="hljs-built_in">String</span> = <span class="hljs-string">&quot;i am screaming&quot;</span>.into();<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> out_file: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();<br>    uppercase(in_file.as_bytes(), &amp;<span class="hljs-keyword">mut</span> out_file).unwrap();<br>    <span class="hljs-keyword">let</span> out_result = <span class="hljs-built_in">String</span>::from_utf8(out_file).unwrap();<br>    <span class="hljs-built_in">assert_eq!</span>(out_result, <span class="hljs-string">&quot;I AM SCREAMING&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144-Lab3实验笔记</title>
    <link href="/202205/cs144-lab3/"/>
    <url>/202205/cs144-lab3/</url>
    
    <content type="html"><![CDATA[<h2 id="实验简介"><a href="#实验简介" class="headerlink" title="实验简介"></a>实验简介</h2><p>Lab3这个实验主要完成的是TCP发送端的功能。应用程序写入字节流到socket，TCP Sender负责将本端的字节流发送到对端。</p><p>具体地说，TCP Sender负责： </p><ul><li><p>根据对端的“接受窗口大小 + 期望收到的下一个字节”，来构造要发送的TCP报文头部和数据。</p></li><li><p>如果超出规定的时间后仍未收到一个已发送报文的应答，则需要重传这个报文。</p></li></ul><p>要实现的功能有：1. 如何构造要发送的TCP头部和数据；2. 处理对端对于发送报文的响应；3. 重传没有收到响应的报文</p><h2 id="实验思路"><a href="#实验思路" class="headerlink" title="实验思路"></a>实验思路</h2><h3 id="1-构造要发送的TCP头部和数据"><a href="#1-构造要发送的TCP头部和数据" class="headerlink" title="1. 构造要发送的TCP头部和数据"></a>1. 构造要发送的TCP头部和数据</h3><p>1.1 想发送数据需要先建立连接（也就是三次握手后才能发送数据）</p><blockquote><p>RFC 793定义的TCP不允许第一个SYN包携带数据，CS144按此实现。</p><p>但TCP Fast Open是允许第一个SYN包携带数据的。<br>参考<a href="https://lwn.net/Articles/508865/">TCP Fast Open: expediting web services</a></p></blockquote><p>1.2 建立连接后按照对端窗口大小减去已发送未被应答的部分，尽可能地用ByteStream内的数据填充TCP DataPayload。报文的序列号应该设置为“报文第一个字节的相对序列号”</p><p>1.3 如果本端ByteStream读到了EOF，并且本TCP报文可以再多携带一个字节，则发送FIN报文。</p><p>1.4 发送新建的报文时，记录这个报文以便重传，直到收到应答；更新下一次会发送的ByteStream用到的绝对序列号。</p><p>1.5 第一个SYN报文，假定对方窗口为1。</p><h3 id="2-对端对于发送报文的响应"><a href="#2-对端对于发送报文的响应" class="headerlink" title="2. 对端对于发送报文的响应"></a>2. 对端对于发送报文的响应</h3><p>对端响应的报文有两个字段需要发送方关心，</p><ul><li><code>ackno</code> 表示对端期望收到下一个数据包的序列号</li><li><code>win_size</code> 表示对端期望接受数据包的最大长度</li></ul><p>收到<code>ackno</code> 后先转换为基于<code>isn</code>的绝对序列号，如果新的绝对序列号小于本端的绝对序列号，说明收到了重复的确认，直接返回即可。</p><p>否则认为所有绝对序列号在新序列号之前的那些报文都已经成功地被对端接受了。</p><h3 id="3-重传没有收到响应的报文"><a href="#3-重传没有收到响应的报文" class="headerlink" title="3. 重传没有收到响应的报文"></a>3. 重传没有收到响应的报文</h3><p>这部分主要参考RFC6298 Section 5的算法实现，按照这个算法，在各个函数里面加一些逻辑即可～</p><p>这个RFC主要规定了TCP如何度量RTO（retransmission timeout），以及在经过一个RTO时间后如何进行重传的算法。</p><p>本实验主要关心如何实现重传算法，这部分内容在<a href="https://www.rfc-editor.org/rfc/rfc6298.html#section-5">Section 5</a>中描述。</p><p>下面给出大致翻译</p><blockquote><p>5.管理RTO计时器</p><p>对于一个重传计时器，<strong>必须满足不能过早地重传这个要求</strong>，也就是不能在小于一个RTO时间内进行重传。<br>以下是管理重传计时器的推荐算法：</p><p>5.1 每次发送包含数据的数据包时（这里的发送包括重传），如果计时器没有启动，则启动计时器。这样计时器才有可能在一个RTO时间后过期（指的是当前的RTO）</p><p>5.2 如果收到了所有“已发送但未被确认”数据的ACK报文后，关闭重传计时器</p><p>5.3 每次收到对新数据的ACK报文时，重启重传计时器，使其可以在一个RTO后过期（指的是当前的RTO）</p><p>当重传计时器过期后，执行如下操作<br>5.4 重传最早的”已发送但未被确认”的TCP段</p><p>5.5 主机（注，这里指TCP发送端）<strong>必须</strong>将新的RTO设置为当前RTO值的两倍。（RTO的上界在本RFC 2.5节中讨论了）</p><p>5.6 启动重传计时器，使其可以在一个RTO后过期（指的是当前的RTO）</p><p>5.7 如果在等待SYN-ACK这个TCP报文时候，重传计时器过期了，并且这个计时器的RTO小于3秒，则当数据传输开始的时候（即，三次握手完成后），RTO必须重新初始化为3秒</p></blockquote><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>计时器的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RetransTimer</span> &#123;</span><br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">uint32_t</span> _remaining_time&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">bool</span> _is_stopped&#123;<span class="hljs-literal">false</span>&#125;;<br>    <span class="hljs-keyword">bool</span> _is_expired&#123;<span class="hljs-literal">false</span>&#125;;<br><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">RetransTimer</span>() : _remaining_time(<span class="hljs-number">0</span>), _is_stopped(<span class="hljs-literal">true</span>), _is_expired(<span class="hljs-literal">false</span>) &#123;&#125;<br>    <span class="hljs-built_in">RetransTimer</span>(<span class="hljs-keyword">uint32_t</span> init_time, <span class="hljs-keyword">bool</span> stopped, <span class="hljs-keyword">bool</span> expired)<br>        : _remaining_time(init_time), _is_stopped(stopped), _is_expired(expired) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tick_to_retrans_timer</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> ms_since_last_tick)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (_is_stopped) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (ms_since_last_tick &gt;= _remaining_time) &#123;<br>            _remaining_time = <span class="hljs-number">0</span>;<br>            _is_expired = <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            _remaining_time -= ms_since_last_tick;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">is_expired</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> _is_expired; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">is_stopped</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> _is_stopped; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">start_new_timer</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> new_rto)</span> </span>&#123;<br>        _remaining_time = new_rto;<br>        _is_expired = <span class="hljs-literal">false</span>;<br>        _is_stopped = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">stop_retrans_timer</span><span class="hljs-params">()</span> </span>&#123;<br>        _is_stopped = <span class="hljs-literal">true</span>;<br>        _is_expired = <span class="hljs-literal">false</span>;<br>        _remaining_time = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>类内新增成员</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TCPSender</span> &#123;</span><br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//! Some TCP state flags send to the other side,</span><br>    <span class="hljs-keyword">bool</span> _syn_sent&#123;<span class="hljs-literal">false</span>&#125;;<br>    <span class="hljs-comment">//! When FIN is sent, it means that the data stream is closed on its own side, `fill_window` will return directly</span><br>    <span class="hljs-keyword">bool</span> _fin_sent&#123;<span class="hljs-literal">false</span>&#125;;<br>    <span class="hljs-comment">//! the receive windows size, from the other side</span><br>    <span class="hljs-keyword">uint16_t</span> _win_size&#123;<span class="hljs-number">1</span>&#125;;<br><br>    <span class="hljs-comment">//! Once the segment is filled the window(using the data payload), it will be sent to the other side</span><br>    <span class="hljs-comment">//! In this lab `send_segments` means move the segment to `_segments_out` FIFO and `_outstanding_segments` map</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">send_segment</span><span class="hljs-params">(TCPSegment &amp;seg)</span></span>;<br>    <span class="hljs-comment">//! keep track of segments which have been sent but not yet acked by the receiver</span><br>    <span class="hljs-comment">//!@&#123;</span><br>    <span class="hljs-comment">// first-&gt; the absolute sequence number, it will be mono increased</span><br>    <span class="hljs-comment">// second-&gt; the outstanding tcp segment</span><br>    std::vector&lt;std::pair&lt;<span class="hljs-keyword">size_t</span>, TCPSegment&gt;&gt; _outstanding_segments&#123;&#125;;<br>    <span class="hljs-keyword">size_t</span> _outstanding_bytes&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-comment">// !@&#125;</span><br><br>    <span class="hljs-comment">//! our initial sequence number, the number for our SYN.</span><br>    WrappingInt32 _isn;<br><br>    <span class="hljs-comment">//! outbound queue of segments that the TCPSender wants sent</span><br>    std::queue&lt;TCPSegment&gt; _segments_out&#123;&#125;;<br><br>    <span class="hljs-comment">//! retransmission timer for the connection</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> _initial_retransmission_timeout;<br>    RetransTimer _retrans_timer&#123;&#125;;<br>    <span class="hljs-comment">//! current retransmission timeout value, aka RTO</span><br>    <span class="hljs-keyword">uint64_t</span> _current_retransmission_timeout&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> _consecutive_retransmission_cnt&#123;<span class="hljs-number">0</span>&#125;;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>方法实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//! \param[in] capacity the capacity of the outgoing byte stream</span><br><span class="hljs-comment">//! \param[in] retx_timeout the initial amount of time to wait before retransmitting the oldest outstanding segment</span><br><span class="hljs-comment">//! \param[in] fixed_isn the Initial Sequence Number to use, if set (otherwise uses a random ISN)</span><br>TCPSender::<span class="hljs-built_in">TCPSender</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> capacity, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint16_t</span> retx_timeout, <span class="hljs-keyword">const</span> std::optional&lt;WrappingInt32&gt; fixed_isn)<br>    : _isn(fixed_isn.<span class="hljs-built_in">value_or</span>(WrappingInt32&#123;<span class="hljs-built_in">random_device</span>()()&#125;))<br>    , _initial_retransmission_timeout&#123;retx_timeout&#125;<br>    , _stream(capacity) &#123;<br>    _current_retransmission_timeout = _initial_retransmission_timeout;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">uint64_t</span> <span class="hljs-title">TCPSender::bytes_in_flight</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> _outstanding_bytes; &#125;<br><br><span class="hljs-comment">//! \details set the segment header and payload, fill the other side receive window size as much as possible</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TCPSender::fill_window</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">size_t</span> receiver_win_size = _win_size ? _win_size : <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> ((receiver_win_size &gt; _outstanding_bytes) &amp;&amp; !_fin_sent) &#123;<br>        TCPSegment seg;<br>        <span class="hljs-keyword">if</span> (!_syn_sent) &#123;<br>            seg.<span class="hljs-built_in">header</span>().syn = <span class="hljs-literal">true</span>;<br>            _syn_sent = <span class="hljs-literal">true</span>;<br>        &#125;<br>        seg.<span class="hljs-built_in">header</span>().seqno = <span class="hljs-built_in">next_seqno</span>();<br><br>        <span class="hljs-comment">// the max bytes could this segment carried</span><br>        <span class="hljs-keyword">size_t</span> max_payload_size =<br>            <span class="hljs-built_in">min</span>(TCPConfig::MAX_PAYLOAD_SIZE, receiver_win_size - _outstanding_bytes - seg.<span class="hljs-built_in">header</span>().syn);<br>        string payload = _stream.<span class="hljs-built_in">read</span>(max_payload_size);<br>        seg.<span class="hljs-built_in">payload</span>() = <span class="hljs-built_in">Buffer</span>(std::<span class="hljs-built_in">move</span>(payload));<br>        <span class="hljs-comment">// send FIN flag if reached EOF of stream</span><br>        <span class="hljs-keyword">if</span> (!_fin_sent &amp;&amp; _stream.<span class="hljs-built_in">eof</span>() &amp;&amp; seg.<span class="hljs-built_in">length_in_sequence_space</span>() + _outstanding_bytes &lt; receiver_win_size) &#123;<br>            seg.<span class="hljs-built_in">header</span>().fin = <span class="hljs-literal">true</span>;<br>            _fin_sent = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (seg.<span class="hljs-built_in">length_in_sequence_space</span>()) &#123;<br>            <span class="hljs-built_in">send_segment</span>(seg);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//! The segment here is NOT EMPTY (non zero length in sequence space)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TCPSender::send_segment</span><span class="hljs-params">(TCPSegment &amp;seg)</span> </span>&#123;<br>    _segments_out.<span class="hljs-built_in">push</span>(seg);<br>    _outstanding_segments.<span class="hljs-built_in">emplace_back</span>(_next_seqno, seg);<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> seg_length = seg.<span class="hljs-built_in">length_in_sequence_space</span>();<br>    _next_seqno += seg_length;<br>    _outstanding_bytes += seg_length;<br><br>    <span class="hljs-keyword">if</span> (_retrans_timer.<span class="hljs-built_in">is_stopped</span>()) &#123;<br>        _retrans_timer.<span class="hljs-built_in">start_new_timer</span>(_current_retransmission_timeout);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//! \param ackno The remote receiver&#x27;s ackno (acknowledgment number)</span><br><span class="hljs-comment">//! \param window_size The remote receiver&#x27;s advertised window size</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TCPSender::ack_received</span><span class="hljs-params">(<span class="hljs-keyword">const</span> WrappingInt32 ackno, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint16_t</span> window_size)</span> </span>&#123;<br>    <span class="hljs-comment">//! `absolute_ackno` is the number of bytes that the receiver received.</span><br>    <span class="hljs-comment">//! `_next_seqno` is the number of bytes that the sender wants to send, i.e. the last `absolute-seqno`</span><br>    <span class="hljs-keyword">size_t</span> absolute_ackno = <span class="hljs-built_in">unwrap</span>(ackno, _isn, _next_seqno);<br>    <span class="hljs-keyword">if</span> (absolute_ackno &gt; _next_seqno) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    _win_size = window_size;<br>    <span class="hljs-comment">//! Remove segments that have now been fully acknoledged segment in `_outstanding_segment`</span><br>    <span class="hljs-keyword">auto</span> iter = _outstanding_segments.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-keyword">bool</span> acked_new_data = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">while</span> (!_outstanding_segments.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;seg = iter-&gt;second;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> seg_length = seg.<span class="hljs-built_in">length_in_sequence_space</span>();<br>        <span class="hljs-keyword">if</span> (iter-&gt;first + seg_length &lt;= absolute_ackno) &#123;<br>            <span class="hljs-comment">// erase returns the iterator following the last removed element.</span><br>            iter = _outstanding_segments.<span class="hljs-built_in">erase</span>(iter);<br>            _outstanding_bytes -= seg_length;<br>            acked_new_data = <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//! When received a valid ackno, which means the receiver receipt of the new data</span><br>    <span class="hljs-comment">//! the retransmission timer will restart if there are outstanding segments (for the current value of RTO).,</span><br>    <span class="hljs-comment">//! otherwise the timer will stop</span><br>    <span class="hljs-keyword">if</span> (acked_new_data) &#123;<br>        _current_retransmission_timeout = _initial_retransmission_timeout;<br>        <span class="hljs-keyword">if</span> (!_outstanding_segments.<span class="hljs-built_in">empty</span>()) &#123;<br>            _retrans_timer.<span class="hljs-built_in">start_new_timer</span>(_current_retransmission_timeout);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            _retrans_timer.<span class="hljs-built_in">stop_retrans_timer</span>();<br>        &#125;<br>        _consecutive_retransmission_cnt = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">fill_window</span>();<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//! \param[in] ms_since_last_tick the number of milliseconds since the last call to this method</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TCPSender::tick</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> ms_since_last_tick)</span> </span>&#123;<br>    _retrans_timer.<span class="hljs-built_in">tick_to_retrans_timer</span>(ms_since_last_tick);<br>    <span class="hljs-comment">// If the retrans_timer is expired, it will retransmit the earliest segment when the window size is not zero</span><br>    <span class="hljs-comment">// then double the RTO, restart a new timer.</span><br>    <span class="hljs-keyword">if</span> (_retrans_timer.<span class="hljs-built_in">is_expired</span>() &amp;&amp; !_outstanding_segments.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> iter = _outstanding_segments.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">if</span> (_win_size &gt; <span class="hljs-number">0</span>) &#123;<br>            _current_retransmission_timeout &lt;&lt;= <span class="hljs-number">1</span>;<br>            _consecutive_retransmission_cnt++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (_consecutive_retransmission_cnt &lt;= TCPConfig::MAX_RETX_ATTEMPTS) &#123;<br>            _segments_out.<span class="hljs-built_in">push</span>(iter-&gt;second);<br>        &#125;<br>        _retrans_timer.<span class="hljs-built_in">start_new_timer</span>(_current_retransmission_timeout);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">TCPSender::consecutive_retransmissions</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> _consecutive_retransmission_cnt; &#125;<br><br><span class="hljs-comment">//! \details The segment with zero data and correct `seqno` is useful for `ACK` the other side.</span><br><span class="hljs-comment">// it will never be retransmitted, and doesn&#x27;t need to keep track.</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TCPSender::send_empty_segment</span><span class="hljs-params">()</span> </span>&#123;<br>    TCPSegment segment;<br>    segment.<span class="hljs-built_in">header</span>().seqno = <span class="hljs-built_in">next_seqno</span>();<br>    _segments_out.<span class="hljs-built_in">push</span>(segment);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>独立的重传计时器的确逻辑清晰很多，第一次实现的时候，发送报文的逻辑和计时器的逻辑混在一次，把我绕晕了。。。</li><li>重传计时器默认应该是关闭的，我第一次实现时候</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>CS144</tag>
      
      <tag>TCP/IP</tag>
      
      <tag>Networking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144-Lab2实验笔记</title>
    <link href="/202205/cs144-lab2/"/>
    <url>/202205/cs144-lab2/</url>
    
    <content type="html"><![CDATA[<h2 id="实验简介"><a href="#实验简介" class="headerlink" title="实验简介"></a>实验简介</h2><p>这个实验主要完成的是，TCP接受端应该如何工作，才能正确地将TCP Payload交付给socket的问题。</p><p>CS144 Lab实现的是这个场景：NIC从链路上收到MAC数据包，交给kernel；kernel解析MAC头后，将这个包传给虚拟的tun设备。CS144 Lab中的其他辅助函数从tun设备中读取IP包，拆包后将完整TCP报文交给<code>tcp_receiver/tcp_sender</code> 这两个我们自己写的程序。</p><p><code>tcp_sender</code> 负责：解析包头、将Payload交付给socket，这样应用程序就能从socket中读取数据了。</p><h2 id="实验思路"><a href="#实验思路" class="headerlink" title="实验思路"></a>实验思路</h2><h3 id="1-序列号与绝对序列号的相互转换"><a href="#1-序列号与绝对序列号的相互转换" class="headerlink" title="1. 序列号与绝对序列号的相互转换"></a>1. 序列号与绝对序列号的相互转换</h3><p>对于这个问题不必考虑SYN&#x2F;FIN是否计算的问题，因为二者都包含了SYN&#x2F;FIN</p><p>1.1 收到的TCP Header中<code>seqno</code>是对端表示其TCP报文内携带的Payload的序列号。</p><ul><li><p>将收到的第一个包（SYN包）携带的<code>seqno</code>称为“起始序列号”，通常是一个32位随机值</p></li><li><p>之后收到的包的<code>seqno</code>则表示当前包携带的Payload相对于“起始序列号”的偏移</p></li></ul><p>1.2 绝对序列号指的是当前包的<code>seqno</code>相对于起始序列号，实际的偏移</p><ul><li>这样就可以知道当前包Payload在乱序字节流里面的起始index了（绝对序列号转到stream index的时候才考虑忽略SYN的问题）</li></ul><p>1.3 绝对序列号转换为序列号</p><ul><li>绝对序列号加上起始序列号对2^32取模即可</li></ul><p>1.4 序列号转换为绝对序列号</p><p>(TODO)</p><h3 id="2-实现TCP接收端"><a href="#2-实现TCP接收端" class="headerlink" title="2. 实现TCP接收端"></a>2. 实现TCP接收端</h3><p>2.1 接收端根据收到TCP包头的<code>seqno + SYN_FLAG + FIN_FLAG + Payload</code> 这几个字段，决定本端的<code>ackno + win_size</code><br>如下图所示<br><img src="/img/cs144-pic/Lab2-TCP-hdr.png"></p><p>2.2 根据当前包的<code>seqno</code>得到绝对序列号，再得到<code>stream index</code></p><ul><li>将Payload按照<code>stream index</code>推到乱序字节流中。乱序如何重组为有序的问题Lab1中已经实现了。</li></ul><p>2.3 向对端响应<code>ackno</code></p><ul><li><code>ackno</code> 指的是本端期望收到下一个数据包的序列号。也就是已经收到的数据的<strong>有序</strong>字节长度加1</li></ul><p>2.4 向对端响应<code>window_size</code></p><ul><li><code>window_size</code> 指的是本端的接受窗口大小，对端按照收到的窗口大小来填充payload的字节数。具体到实验就是接收端乱序字节流的最大容量减去有序字节流中的字节数（已经重组但未被应用程序读取这部分）。</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>TCPReceiver类内新增一些变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TCPReceiver</span> &#123;</span><br>    <span class="hljs-comment">//! Some TCP Flag received in the first and the last segment from other side</span><br>    <span class="hljs-keyword">bool</span> _syn&#123;<span class="hljs-literal">false</span>&#125;;<br>    <span class="hljs-keyword">bool</span> _fin&#123;<span class="hljs-literal">false</span>&#125;;<br>    WrappingInt32 _isn&#123;<span class="hljs-number">0</span>&#125;;<br><br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>具体的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//  libsponge/tcp_receiver.cc </span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TCPReceiver::segment_received</span><span class="hljs-params">(<span class="hljs-keyword">const</span> TCPSegment &amp;seg)</span> </span>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;hdr = seg.<span class="hljs-built_in">header</span>();<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;data = seg.<span class="hljs-built_in">payload</span>();<br>    <span class="hljs-comment">// Not receive SYN yet</span><br>    <span class="hljs-keyword">if</span> (!_syn) &#123;<br>        <span class="hljs-keyword">if</span> (!hdr.syn) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            _syn = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">// the sequence number of the first segment is the initial sequence number</span><br>            _isn = hdr.seqno;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// NOW, received SYN from the other side</span><br>    <span class="hljs-keyword">if</span> (hdr.fin) &#123;<br>        _fin = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">// the checkpoint should be the last absolute sequence number</span><br>    <span class="hljs-keyword">size_t</span> ckpt = <span class="hljs-built_in">stream_out</span>().<span class="hljs-built_in">bytes_written</span>() + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">uint64_t</span> absolute_seqno = <span class="hljs-built_in">unwrap</span>(hdr.seqno, _isn, ckpt);<br>    <span class="hljs-comment">// In the first segment, the stream index should be 0, or this index should be absolute seqno minus 1</span><br>    <span class="hljs-keyword">uint64_t</span> stream_idx = absolute_seqno + <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint64_t</span>&gt;(hdr.syn) - <span class="hljs-number">1</span>;<br>    _reassembler.<span class="hljs-built_in">push_substring</span>(data.<span class="hljs-built_in">copy</span>(), stream_idx, _fin);<br>&#125;<br><br><span class="hljs-function">optional&lt;WrappingInt32&gt; <span class="hljs-title">TCPReceiver::ackno</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!_syn) &#123;<br>        <span class="hljs-keyword">return</span> nullopt;<br>    &#125;<br>    <span class="hljs-comment">// written bytes + SYN</span><br>    <span class="hljs-keyword">uint64_t</span> absolute_ackno = <span class="hljs-built_in">stream_out</span>().<span class="hljs-built_in">bytes_written</span>() + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// Only when there is no segment on the fly and receive the FIN flag, then the absolute seq should add 1</span><br>    absolute_ackno += (_fin &amp;&amp; _reassembler.<span class="hljs-built_in">unassembled_bytes</span>() == <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">wrap</span>(absolute_ackno, _isn);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">TCPReceiver::window_size</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-comment">// the capacity minus the bytes have been reassembled, but not consumed</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;_capacity - <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">stream_out</span>().<span class="hljs-built_in">buffer_size</span>();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>CS144</tag>
      
      <tag>TCP/IP</tag>
      
      <tag>Networking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144-Lab1实验笔记</title>
    <link href="/202205/cs144-lab1/"/>
    <url>/202205/cs144-lab1/</url>
    
    <content type="html"><![CDATA[<h2 id="实验简介"><a href="#实验简介" class="headerlink" title="实验简介"></a>实验简介</h2><p>Lab0中完成了有序字节流的写入和读出，这个实验需要完成乱序字节流的重组、写入和读出。也就是说，Lab1实验手册中的这幅图，蓝色和绿色部分我们已经在Lab0中完成了，我们在Lab1中只需要完成红色部分的重组即可。</p><p><img src="/img/cs144-pic/lab1-stream.png"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>(这个思路有很大的性能优化空间)</p><ol><li>使用map存储乱序字节流，<code>key=(起始下标，结束下标)</code>，均从0开始，<code>value=(字符串)</code>，<code>pair&lt;int,int&gt;</code>作为key的时候不需要自己写比较函数。</li><li>每当有新字符串push进来后，在map中确定要插入的位置（应该插入到low_bound返回的之前一个），不断判断当前字符串是否能合并之前一个键值对或者之后的一个。</li><li>如果当前map的第一个元素可以插入到有序字节流中，弹出完整的第一个元素，或者部分第一个元素。</li><li>只有当“当前不存在乱序字节，且已经收到了对端发来的EOF标志”，有序字节流的<code>end_of_input</code>才有效。有一种情况是，收到了对端发来的EOF标志（收到了FIN包），但是中间仍有未收到的片段（空洞），这时候有序字节流不能结束。</li><li>注意一些conner case，比如写入有序字节流的时候当前字符串不一定能全部写入。</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>类内新增变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// libsponge/stream_reassembler.hh  </span><br><span class="hljs-keyword">size_t</span> _unassembled_bytes&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">size_t</span> _first_unassembled_index&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">bool</span> _eof&#123;<span class="hljs-literal">false</span>&#125;;<br><span class="hljs-comment">// key-&gt; &lt;start_idx, end_idx&gt;, value -&gt; str_to_assembled</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">recv_bytes_t</span> = pair&lt;pair&lt;<span class="hljs-keyword">size_t</span>, <span class="hljs-keyword">size_t</span>&gt;, std::string&gt;;<br>map&lt;pair&lt;<span class="hljs-keyword">size_t</span>, <span class="hljs-keyword">size_t</span>&gt;, std::string&gt; _str_to_assemble;<br><br>ByteStream _output;  <span class="hljs-comment">//!&lt; The reassembled in-order byte stream</span><br><span class="hljs-keyword">size_t</span> _capacity;    <span class="hljs-comment">//!&lt; The maximum number of bytes</span><br><br><span class="hljs-function"><span class="hljs-keyword">recv_bytes_t</span> <span class="hljs-title">merge_two_unassembled_strs</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">recv_bytes_t</span> &amp;a, <span class="hljs-keyword">const</span> <span class="hljs-keyword">recv_bytes_t</span> &amp;b)</span> <span class="hljs-keyword">const</span></span>;<br></code></pre></td></tr></table></figure><p><code>push_string</code> 方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//! \details This function accepts a substring (aka a segment) of bytes,</span><br><span class="hljs-comment">//! possibly out-of-order, from the logical stream, and assembles any newly</span><br><span class="hljs-comment">//! contiguous substrings and writes them into the output stream in order.</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">StreamReassembler::push_substring</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string &amp;data, <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> index, <span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> eof)</span> </span>&#123;<br>    <span class="hljs-keyword">size_t</span> cur_win_max_idx = _first_unassembled_index + _capacity - _output.<span class="hljs-built_in">buffer_size</span>();<br>    <span class="hljs-keyword">if</span> (index &gt;= cur_win_max_idx)<br>        <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">if</span> (eof) &#123;<br>        _eof = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">// cut the chars which are out of window or have been assembled</span><br>    <span class="hljs-keyword">size_t</span> data_start_idx = <span class="hljs-built_in">max</span>(index, _first_unassembled_index);<br>    <span class="hljs-keyword">size_t</span> data_end_idx = <span class="hljs-built_in">min</span>(cur_win_max_idx, index + data.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-keyword">if</span> (data_end_idx &gt;= data_start_idx) &#123;<br>        pair&lt;<span class="hljs-keyword">size_t</span>, <span class="hljs-keyword">size_t</span>&gt; cur_data_start_end_index = <span class="hljs-built_in">make_pair</span>(data_start_idx, data_end_idx);<br>        string cur_data = data.<span class="hljs-built_in">substr</span>(data_start_idx - index, data_end_idx - data_start_idx + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// insert current data to str_to_assemble map</span><br>        <span class="hljs-keyword">recv_bytes_t</span> cur_recv_bytes = &#123;cur_data_start_end_index, cur_data&#125;;<br>        <span class="hljs-keyword">while</span> (!<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> iter = _str_to_assemble.<span class="hljs-built_in">lower_bound</span>(cur_data_start_end_index);<br>            <span class="hljs-keyword">bool</span> cur_data_could_merge_right =<br>                (iter != _str_to_assemble.<span class="hljs-built_in">end</span>()) &amp;&amp; (cur_recv_bytes.first.second &gt;= iter-&gt;first.first);<br>            <span class="hljs-keyword">if</span> (cur_data_could_merge_right) &#123;<br>                cur_recv_bytes = <span class="hljs-built_in">merge_two_unassembled_strs</span>(cur_recv_bytes, *iter);<br>                _unassembled_bytes -= iter-&gt;second.<span class="hljs-built_in">size</span>();<br>                _str_to_assemble.<span class="hljs-built_in">erase</span>(iter);<br>                iter = _str_to_assemble.<span class="hljs-built_in">lower_bound</span>(cur_data_start_end_index);<br>            &#125;<br><br>            <span class="hljs-keyword">bool</span> cur_data_could_merge_left =<br>                (iter != _str_to_assemble.<span class="hljs-built_in">begin</span>()) &amp;&amp; ((--iter)-&gt;first.second &gt;= cur_recv_bytes.first.first);<br>            <span class="hljs-keyword">if</span> (cur_data_could_merge_left) &#123;<br>                cur_recv_bytes = <span class="hljs-built_in">merge_two_unassembled_strs</span>(*iter, cur_recv_bytes);<br>                _unassembled_bytes -= iter-&gt;second.<span class="hljs-built_in">size</span>();<br>                _str_to_assemble.<span class="hljs-built_in">erase</span>(iter);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!cur_data_could_merge_right &amp;&amp; !cur_data_could_merge_left) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// insert the unassembled str to map</span><br>        _str_to_assemble.<span class="hljs-built_in">insert</span>(cur_recv_bytes);<br>        _unassembled_bytes += cur_recv_bytes.second.<span class="hljs-built_in">size</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// if the first chunk start index is smaller than _first_unassembled_index</span><br>    <span class="hljs-comment">// write the first chunk to output bytestream</span><br>    <span class="hljs-keyword">auto</span> iter = _str_to_assemble.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-keyword">if</span> (!_str_to_assemble.<span class="hljs-built_in">empty</span>() &amp;&amp; (iter-&gt;first.first &lt;= _first_unassembled_index)) &#123;<br>        <span class="hljs-keyword">auto</span> temp_map_head = *iter;<br>        _str_to_assemble.<span class="hljs-built_in">erase</span>(iter);<br>        <span class="hljs-keyword">size_t</span> written_len = _output.<span class="hljs-built_in">write</span>(temp_map_head.second);<br>        _unassembled_bytes -= written_len;<br>        <span class="hljs-keyword">if</span> (written_len == temp_map_head.second.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-comment">// The first chunk was all written to the output stream</span><br>            _first_unassembled_index = temp_map_head.first.first + temp_map_head.second.<span class="hljs-built_in">size</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Part of first chunk was written to the output stream</span><br>            <span class="hljs-keyword">size_t</span> new_data_start_index = temp_map_head.first.first + written_len;<br>            _str_to_assemble.<span class="hljs-built_in">insert</span>(<br>                &#123;&#123;new_data_start_index, temp_map_head.first.second&#125;, temp_map_head.second.<span class="hljs-built_in">substr</span>(written_len)&#125;);<br>            _first_unassembled_index = new_data_start_index;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>() &amp;&amp; _eof) &#123;<br>        _output.<span class="hljs-built_in">end_input</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//! \details This function merge two recv_bytes_type pairs, the start index of a is always smaller than b.</span><br><span class="hljs-function">StreamReassembler::<span class="hljs-keyword">recv_bytes_t</span> <span class="hljs-title">StreamReassembler::merge_two_unassembled_strs</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">const</span> StreamReassembler::<span class="hljs-keyword">recv_bytes_t</span> &amp;a,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">const</span> StreamReassembler::<span class="hljs-keyword">recv_bytes_t</span> &amp;b)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">recv_bytes_t</span> res;<br>    res.first.first = a.first.first;<br>    <span class="hljs-comment">// choose the bigger one for the end index of merged string.</span><br>    <span class="hljs-keyword">if</span> (a.first.second &gt; b.first.second) &#123;<br>        res.first.second = a.first.second;<br>        res.second = a.second;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        res.first.second = b.first.second;<br>        res.second = a.second.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, b.first.first - a.first.first) + b.second;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>CS144</tag>
      
      <tag>TCP/IP</tag>
      
      <tag>Networking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144-实验环境搭建和Lab0</title>
    <link href="/202205/cs144-lab0/"/>
    <url>/202205/cs144-lab0/</url>
    
    <content type="html"><![CDATA[<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><ol><li>这次打算用 Jetbrains Gateway进行远程开发。按照 CS144 README 进行远端Clion的配置。注意环境变量和编译时传给cmake的宏的设置。<br><img src="/img/cs144-pic/lab0-clion-debug.png"></li><li>安装TcpDump，最好从Github的源码编译安装，5.0版本后的tcpdump可以保存pcap文件中同时输出到标准输出流中。</li></ol><h2 id="实验0"><a href="#实验0" class="headerlink" title="实验0"></a>实验0</h2><p>使用TCPsocket和一个webserver（对端监听80端口）进行通信，类似于curl。</p><p>代码十分简单，按照socket通信流程编写即可。lab0仅完成下图中描述的TCP客户端流程即可</p><blockquote><p><img src="/img/cs144-pic/socket-client&server.png"></p><p>图片来源微信公众号<a href="https://mp.weixin.qq.com/s/Ytw_N5zeLH50ItdgAsv3nA">Linux fd 系列 — socket fd 是什么？</a></p></blockquote><p>下面给出我的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_URL</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;host, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;path)</span> </span>&#123;<br>    <span class="hljs-comment">// Your code here.</span><br><br>    <span class="hljs-comment">// You will need to connect to the &quot;http&quot; service on</span><br>    <span class="hljs-comment">// the computer whose name is in the &quot;host&quot; string,</span><br>    <span class="hljs-comment">// then request the URL path given in the &quot;path&quot; string.</span><br>    TCPSocket sock&#123;&#125;;<br>    sock.connect(Address(host, <span class="hljs-string">&quot;http&quot;</span>));<br>    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">input_str</span><span class="hljs-params">(<span class="hljs-string">&quot;GET &quot;</span> + path + <span class="hljs-string">&quot; HTTP/1.1\r\nHost: &quot;</span> + host + <span class="hljs-string">&quot;\r\n\r\n&quot;</span>)</span></span>;<br>    sock.write(input_str);<br><br>    <span class="hljs-comment">// Then you&#x27;ll need to print out everything the server sends back,</span><br>    <span class="hljs-comment">// (not just one call to read() -- everything) until you reach</span><br>    <span class="hljs-comment">// the &quot;eof&quot; (end of file).</span><br>    sock.shutdown(SHUT_WR);<br>    <span class="hljs-keyword">while</span> (!sock.eof())<br>        <span class="hljs-built_in">cout</span> &lt;&lt; sock.read();<br>    sock.close();<br>    <span class="hljs-comment">// cerr &lt;&lt; &quot;Function called: get_URL(&quot; &lt;&lt; host &lt;&lt; &quot;, &quot; &lt;&lt; path &lt;&lt; &quot;).\n&quot;;</span><br>    <span class="hljs-comment">// cerr &lt;&lt; &quot;Warning: get_URL() has not been implemented yet.\n&quot;;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ol><li><p>如果使用Clion的话，需要先build All Test，再运行相关测试。测试的那些target只运行测试不进行编译链接</p></li><li><p>进行抓包测试。  我的客户端是先半关闭，再一点点读对端发来的数据。抓到的包也反映了这一点</p><p> 如果使用5.0版本的tcpdump的话，可以使用–print参数。否则只能先保存，再查看。</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo tcpdump  -i any -ent host cs144.keithw.org -w ./pcap/lab0.pcap<br></code></pre></td></tr></table></figure><p><img src="/img/cs144-pic/lab0-pcap.png"></p><blockquote><p>这里使用了Vscode Crumbs插件用来在Vscode中看pcap包</p></blockquote><h2 id="附：CS144代码风格"><a href="#附：CS144代码风格" class="headerlink" title="附：CS144代码风格"></a>附：CS144代码风格</h2><p>CS144 使用 C++11 标准完成实验，它对C++代码的风格有着严格的限制：</p><ul><li><p>使用 Resource acquisition is initialization 风格，即 RAII 风格。</p></li><li><p>禁止使用 malloc 和 free 函数</p></li><li><p>禁止使用 new 和 delete 关键字</p></li><li><p>禁止使用原生指针（*）。若有必要，最好使用智能指针（unique_ptr等等）。(该实验没有必要用到指针)。</p></li><li><p>禁止使用模板、线程相关、各类锁机制以及虚函数</p></li><li><p>禁止使用 C 风格字符串(char*) 以及 C 风格字符串处理函数。使用 string 来代替。</p></li><li><p>禁止使用 C 风格强制类型转换。若有必要请使用 static_cast</p></li><li><p>传递参数给函数时，请使用常量引用类型（const Ty&amp; t）</p></li><li><p>尽可能将每个变量和函数方法都声明成 const</p></li><li><p>禁止使用全局变量，以及尽可能让每个变量的作用域最小</p></li><li><p>在完成代码后，务必使用 make format 来标准化代码风格。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>CS144</tag>
      
      <tag>TCP/IP</tag>
      
      <tag>Networking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tmux配置与美化</title>
    <link href="/202107/tmux-tutorial/"/>
    <url>/202107/tmux-tutorial/</url>
    
    <content type="html"><![CDATA[<p>本文介绍了我目前使用的Tmux配置。一来是目前的配置用着还算舒服，写此文安利一下；二来也记录一下键位映射，以做备忘。</p><p><a href="https://github.com/Gwzlchn/dotConfig/tree/master/tmux">我的Tmux配置目录</a></p><h2 id="Oh-My-Tmux"><a href="#Oh-My-Tmux" class="headerlink" title="Oh-My-Tmux"></a>Oh-My-Tmux</h2><p>目前我用的配置是基于<a href="https://github.com/gpakosz/.tmux"><code>Oh-My-Tmux</code></a>项目改造的。在这个项目上我进行了一些配色的改变（原生的黑白红是在欣赏不起来），最终效果如下图1所示，环境为<code>Windows Terminal + WSL2 + Tmux 3.0a</code><br><img src="/img/2021-07-19-tmux-tutorial/tmux-nord.png" alt="图1：Tmux效果图"></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li><p>配置文件的安装<br><em><strong>这里是对oh-my-tmux的安装流程复述</strong></em></p><ul><li><p>前置条件</p><ul><li><code>Tmux</code>版本大于等于2.4。Tmux的版本可以通过<code>tmux -V</code>命令查看。</li><li>预装awk、perl、sed工具</li><li><code>$TERM</code>变量必须设置为<code>xterm-256color</code>。这个变量是在<code>~/.bashrc</code>中设置的，<code>echo $TERM</code>可以检查。</li></ul></li><li><p>安装配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span><br>$ git <span class="hljs-built_in">clone</span> https://github.com/Gwzlchn/dotConfig.git<br>$ ln -s -f ~/dotConfig/tmux/.tmux.conf<br>$ cp ~/dotConfig/tmux/.tmux.conf.local .<br></code></pre></td></tr></table></figure></li></ul></li><li><p>字体的安装<br>本配置文件中的一些符号图标的显示依赖<code>Nerd Font</code>字体，所以需要在终端软件所在的系统中安装<code>Nerd Font</code>字体。   </p><p><code>Nerd Font</code>并不是一种字体，而是在原有字体上增加了一些Unicode符号的一个字体补丁。你既可以选择手动为自己目前用的字体打上<code>Nerd Font</code>补丁（参考<a href="https://zhuanlan.zhihu.com/p/150097941">使用nerd-font&#x2F;font-patcher为字体添加字体图标</a>），也可以在<a href="https://www.nerdfonts.com/font-downloads">Nerd Font Download</a>页面下载打好补丁后的字体。我用的是<code>FiraCode NerdFont</code>，这个字体看起来比较纤细，同时带连字符效果。  </p><p>我目前用的终端是<code>Windows Terminal</code>,Windows安装字体比较简单，点开字体安装即可。之后需要将终端软件配置为刚刚安装的字体。打开<code>Windows Terminal</code>的配置文件<code>settings.json</code>，在<code>profiles.defaults</code>字段下增加<code>&quot;fontFace&quot;: xxxx</code>这个属性。如下所示。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs json"> <span class="hljs-string">&quot;profiles&quot;</span>:<br> &#123;<br>     <span class="hljs-attr">&quot;defaults&quot;</span>:<br>     &#123;<br>         <span class="hljs-comment">// Put settings here that you want to apply to all profiles.</span><br>         <span class="hljs-comment">// &quot;colorScheme&quot;: &quot;Dracula&quot;,</span><br>         <span class="hljs-comment">//&quot;acrylicOpacity&quot; : 0.4,</span><br>         <span class="hljs-attr">&quot;useAcrylic&quot;</span> : <span class="hljs-literal">true</span>,<br>         <span class="hljs-attr">&quot;fontSize&quot;</span>:<span class="hljs-number">13</span>,<br>         <span class="hljs-attr">&quot;fontFace&quot;</span>: <span class="hljs-string">&quot;FiraCode Nerd Font&quot;</span>,<br>         <span class="hljs-attr">&quot;startingDirectory&quot;</span>: <span class="hljs-string">&quot;.&quot;</span>,<br>         <span class="hljs-attr">&quot;bellStyle&quot;</span>:<span class="hljs-string">&quot;none&quot;</span><br>     &#125;,<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>如果完成了上述的安装流程，那么你在<code>Windows Terminal</code>中进入<code>WSL2</code>环境后，输入<code>tmux</code>应该就可以看到图1的效果了。</p></li></ol><h2 id="键位映射"><a href="#键位映射" class="headerlink" title="键位映射"></a>键位映射</h2><p>Tmux另一个迷人之处在于你可以用纯键盘来控制终端窗口的增删查改、甚至是缩放与恢复(<del>1.意味着极大概率会碰到Tmux快捷键与其他软件冲突的情况。2.意味着我经常记不住冷门的快捷键映射</del>。3.意味着你可以套用VIM的键位映射，但这里我没有用，<del>因为我不熟VIM</del>)。</p><p><strong>一些键位符号的约定</strong></p><ol><li><code>&lt;prefix&gt;</code> 表示前缀键，需要同时按<code>Ctrl + b</code>触发。按下之后状态栏会有提示，表示等待后续按键的输入（Oh-my-tmux效仿Screen，将<code>Ctrl+a</code>也映射成了前缀键，但会和<code>Qemu</code>冲突，故我这里取消了这个映射）</li><li><code>&lt;prefix&gt; c</code> 表示新建一个窗口，需要先同时按<code>Ctrl + b</code>，再按<code>c</code>键触发。</li><li><code>&lt;prefix&gt; C-c</code> 表示新建一个会话，需要先同时按<code>Ctrl + b</code>，再同时按<code>Ctrl - c</code>键触发。</li><li><code>&lt;CR&gt;</code>表示回车</li></ol><table><thead><tr><th>键位映射</th><th>动作</th><th>备注</th></tr></thead><tbody><tr><td><code>&lt;prefix&gt; e</code></td><td>编辑<code>~/.tmux.conf.local</code>配置文件</td><td></td></tr><tr><td><code>&lt;prefix&gt; r</code></td><td>重新加载<code>~/.tmux.conf.local</code>配置</td><td></td></tr><tr><td><code>&lt;prefix&gt; C-c</code></td><td>新建一个Session</td><td></td></tr><tr><td><code>&lt;prefix&gt; c</code></td><td>新建一个Window</td><td></td></tr><tr><td><code>&lt;prefix&gt; $</code></td><td>重命名当前Session</td><td></td></tr><tr><td><code>&lt;prefix&gt; ,</code></td><td>重命名当前Window</td><td></td></tr><tr><td><code>&lt;prefix&gt; %</code></td><td>新建一个垂直方向的Panel</td><td></td></tr><tr><td><code>&lt;prefix&gt; _</code> (下划线)</td><td>同上</td><td></td></tr><tr><td><code>&lt;prefix&gt; “</code></td><td>新建一个水平方向的Panel</td><td></td></tr><tr><td><code>&lt;prefix&gt; -</code> (减号)</td><td>同上</td><td></td></tr><tr><td><code>&lt;prefix&gt; w</code></td><td>查看所有打开的Session和Windows</td><td>可以通过<code>j/k &lt;CR&gt;</code>来跳转</td></tr><tr><td><code>&lt;prefix&gt;  + Up/Left/Down/Right</code></td><td>更改一个Window内Panel大小</td><td>按方向键的时候，<code>&lt;prefix&gt;</code>不要松开</td></tr><tr><td><code>&lt;prefix&gt; h/j/k/l</code></td><td>在一个Window内切换到不同的Panel中</td><td>使用方向键亦可，按方向键的时候，<code>&lt;prefix&gt;</code>需要松开</td></tr><tr><td><code>&lt;prefix&gt; &lt;</code>&#x2F;<code>&lt;prefix&gt; &gt;</code></td><td>交换两个Panel的位置</td><td></td></tr><tr><td><code>&lt;prefix&gt; C-h</code>&#x2F;<code>&lt;prefix&gt; C-l</code></td><td>在一个Session内的不同Window中切换</td><td>默认的<code>&lt;prefix&gt; n/p</code>切换方式已解绑</td></tr><tr><td><code>&lt;prefix&gt; +</code></td><td>将当前Panel最大化成为一个Window，或者恢复一个Window为Panel</td><td><strong>这个是Oh-My-Tmux最有用的功能</strong></td></tr><tr><td><code>&lt;prefix&gt; m</code></td><td>Tmux鼠标模式开关</td><td>默认开</td></tr><tr><td><code>&lt;prefix&gt; &lt;CR&gt;</code>&#x2F;<code>&lt;prefix&gt; [</code></td><td>进入Tmux 复制模式</td><td></td></tr><tr><td>Copy Mode <code>q</code></td><td>退出复制模式</td><td>在复制模式下</td></tr><tr><td>Copy Mode <code>C-Space</code></td><td>开始复制</td><td>同上</td></tr><tr><td>Copy Mode <code>C-w</code></td><td>将选中内容复制到Tmux Buffer中</td><td>同上</td></tr><tr><td><code>&lt;prefix&gt; p</code>&#x2F;<code>&lt;prefix&gt; ]</code></td><td>将最新的Tmux Buffer中的内容粘贴到终端中</td><td></td></tr><tr><td><code>&lt;prefix&gt; P</code></td><td>选择任意Tmux Buffer中的内容粘贴到终端中</td><td></td></tr><tr><td><code>&lt;prefix&gt; b</code></td><td>查看目前所有的Tmux Buffer中的内容</td><td></td></tr></tbody></table><h2 id="美化Tmux"><a href="#美化Tmux" class="headerlink" title="美化Tmux"></a>美化Tmux</h2><p>Oh-My-Tmux给了较大的美化空间，如图2所示。四个方框依次对应的是1.status left, 2.window status, 3.window current status, 4.status right。清楚了这个对应关系，再看<code>~/.tmux.conf.local</code>中的内容就很清楚了。右侧状态栏比较好的一点是，当你使用的SSH登录到远程主机时，username和hostname也会随之改变。</p><p>配色方案我这里选用的是<a href="https://www.nordtheme.com/docs/colors-and-palettes">Nord Color Scheme</a><br><img src="/img/2021-07-19-tmux-tutorial/tmux-statusbar.png" alt="图2：Tmux状态栏效果"></p><p>最后附上我目前用的状态栏配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs config"># window status style<br>#   - built-in variables are:<br>#     - #&#123;circled_window_index&#125;<br>#     - #&#123;circled_session_name&#125;<br>#     - #&#123;hostname&#125;<br>#     - #&#123;hostname_ssh&#125;<br>#     - #&#123;hostname_full&#125;<br>#     - #&#123;hostname_full_ssh&#125;<br>#     - #&#123;username&#125;<br>#     - #&#123;username_ssh&#125;<br>tmux_conf_theme_window_status_fg=$nord5             <br>tmux_conf_theme_window_status_bg=$nord1              <br>tmux_conf_theme_window_status_attr=&quot;none&quot;<br>tmux_conf_theme_window_status_format=&quot;#I #W&quot;<br><br># window current status style<br>#   - built-in variables are:<br>#     - #&#123;circled_window_index&#125;<br>#     - #&#123;circled_session_name&#125;<br>#     - #&#123;hostname&#125;<br>#     - #&#123;hostname_ssh&#125;<br>#     - #&#123;hostname_full&#125;<br>#     - #&#123;hostname_full_ssh&#125;<br>#     - #&#123;username&#125;<br>#     - #&#123;username_ssh&#125;<br>#   ﲵ            ﮊ ﮏ ♥ ﰸ ﯅  <br>tmux_conf_theme_window_status_current_fg=$nord6      <br>tmux_conf_theme_window_status_current_bg=$nord10 <br>tmux_conf_theme_window_status_current_attr=&quot;bold&quot;<br>tmux_conf_theme_window_status_current_format=&quot; #W&quot;<br><br># window activity status style<br>tmux_conf_theme_window_status_activity_fg=&quot;default&quot;<br>tmux_conf_theme_window_status_activity_bg=&quot;default&quot;<br>tmux_conf_theme_window_status_activity_attr=&quot;underscore&quot;<br><br># window bell status style<br>tmux_conf_theme_window_status_bell_fg=&#x27;#ffff00&#x27; <br>tmux_conf_theme_window_status_bell_bg=&quot;default&quot;<br>tmux_conf_theme_window_status_bell_attr=&quot;blink,bold&quot;<br><br># window last status style<br>tmux_conf_theme_window_status_last_fg=&quot;default&quot;<br>tmux_conf_theme_window_status_last_bg=&quot;default&quot;<br>tmux_conf_theme_window_status_last_attr=&quot;none&quot;<br>tmux_conf_theme_window_status_last_format=&#x27;#I #W-&#x27;<br><br># status left/right content:<br>#   - separate main sections with &quot;|&quot;<br>#   - separate subsections with &quot;,&quot;<br>#   - built-in variables are:<br>#     - #&#123;battery_bar&#125;<br>#     - #&#123;battery_hbar&#125;<br>#     - #&#123;battery_percentage&#125;<br>#     - #&#123;battery_status&#125;<br>#     - #&#123;battery_vbar&#125;<br>#     - #&#123;circled_session_name&#125;<br>#     - #&#123;hostname_ssh&#125;<br>#     - #&#123;hostname&#125;<br>#     - #&#123;hostname_full&#125;<br>#     - #&#123;hostname_full_ssh&#125;<br>#     - #&#123;loadavg&#125;<br>#     - #&#123;mouse&#125;<br>#     - #&#123;pairing&#125;<br>#     - #&#123;prefix&#125;<br>#     - #&#123;root&#125;<br>#     - #&#123;synchronized&#125;<br>#     - #&#123;uptime_y&#125;<br>#     - #&#123;uptime_d&#125; (modulo 365 when #&#123;uptime_y&#125; is used)<br>#     - #&#123;uptime_h&#125;<br>#     - #&#123;uptime_m&#125;<br>#     - #&#123;uptime_s&#125;<br>#     - #&#123;username&#125;<br>#     - #&#123;username_ssh&#125;<br>tmux_conf_theme_status_left=&quot;  #S &quot;<br>#tmux_conf_theme_status_right=&quot;#&#123;prefix&#125;#&#123;mouse&#125;#&#123;pairing&#125;#&#123;synchronized&#125;#&#123;?battery_status,#&#123;battery_status&#125;,&#125;#&#123;?battery_bar, #&#123;battery_bar&#125;,&#125;#&#123;?battery_percentage, #&#123;battery_percentage&#125;,&#125; , %R , %d %b | #&#123;username&#125;#&#123;root&#125; | #&#123;hostname&#125; &quot;<br>tmux_conf_theme_status_right=&#x27;#&#123;prefix&#125;#&#123;pairing&#125;#&#123;synchronized&#125;#&#123;?battery_bar, #&#123;battery_bar&#125;,&#125;#&#123;?battery_percentage, #&#123;battery_percentage&#125;,&#125;#&#123;?battery_status,#&#123;battery_status&#125;,&#125; | %b %d | %R | <br>tmux_conf_theme_status_left_fg=$nord5 # &#x27;#e4e4e4,#e4e4e4,#e4e4e4&#x27;  # black, white , white<br>tmux_conf_theme_status_left_bg=$nord0 #&#x27;,#00afff&#x27;  # yellow, pink, white blue<br>tmux_conf_theme_status_left_attr=&#x27;bold,none,none&#x27;<br><br># status right style<br>#tmux_conf_theme_status_right_fg=&quot;$tmux_conf_theme_colour_12,$tmux_conf_theme_colour_13,$tmux_conf_theme_colour_14&quot;<br>#tmux_conf_theme_status_right_bg=&quot;$tmux_conf_theme_colour_15,$tmux_conf_theme_colour_16,$tmux_conf_theme_colour_17&quot;<br>tmux_conf_theme_status_right_fg=$nord4,$nord6,$nord6,$nord5,$nord5<br>tmux_conf_theme_status_right_bg=$nord1,$nord7,$nord10,$nord2,$nord1 # dark gray, red, white<br>tmux_conf_theme_status_right_attr=&#x27;bold,none,bold,none,none,none&#x27;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>tmux</tag>
      
      <tag>dotConfig</tag>
      
      <tag>折腾</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[MIT-6.S081/Fall2020] 实验笔记零 Lab0: Preparation</title>
    <link href="/202106/6-s081-lab0/"/>
    <url>/202106/6-s081-lab0/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h2><p>为了更好地理解RISC-V指令集，也为了熟悉QEMU，所以选择刷一遍MIT-6.S081的实验。希望不仅仅以做Lab为目的，同时也精读几篇OS领域经典文章。</p><hr><p><strong>可能好多人都卡在环境准备上，但后来我发现：趁早动手做实验，比准备环境更重要~</strong></p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>参考 6.S081 官方的配置教程：<a href="https://pdos.csail.mit.edu/6.S081/2020/tools.html">Tools</a></p><p>本人用的环境是基于<code>Qemu(KVM)</code>上的<code>Ubuntu 20.04</code>。</p><p>首先安装RISC-V工具链、GDB-Multiarch、QEMU：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu  binutils-riscv64-linux-gnu gcc-riscv64-unknown-elf<br><br><span class="hljs-comment"># fix qemu</span><br>sudo apt-get remove qemu-system-misc<br>sudo apt-get install qemu-system-misc=1:4.2-3ubuntu6<br></code></pre></td></tr></table></figure><p>检查一遍自己的环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ riscv64-linux-gnu-gcc --version<br>riscv64-linux-gnu-gcc (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0<br>Copyright (C) 2019 Free Software Foundation, Inc.<br>This is free software; see the <span class="hljs-built_in">source</span> <span class="hljs-keyword">for</span> copying conditions.  There is NO<br>warranty; not even <span class="hljs-keyword">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.<br><br>$ qemu-system-riscv64 --version<br>QEMU emulator version 4.2.0 (Debian 1:4.2-3ubuntu6)<br>Copyright (c) 2003-2019 Fabrice Bellard and the QEMU Project developers<br><br>$ riscv64-unknown-elf-gcc --version<br>riscv64-unknown-elf-gcc () 9.3.0<br>Copyright (C) 2019 Free Software Foundation, Inc.<br>This is free software; see the <span class="hljs-built_in">source</span> <span class="hljs-keyword">for</span> copying conditions.  There is NO<br>warranty; not even <span class="hljs-keyword">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.<br></code></pre></td></tr></table></figure><h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><p>能在<code>QEMU</code>中启动<code>xv6</code>，环境就算准备完了，可以动手做实验了~</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> git://g.csail.mit.edu/xv6-labs-2020<br>Cloning into <span class="hljs-string">&#x27;xv6-labs-2020&#x27;</span>...<br>...<br>$ <span class="hljs-built_in">cd</span> xv6-labs-2020<br>$ git checkout util<br>Branch <span class="hljs-string">&#x27;util&#x27;</span> <span class="hljs-built_in">set</span> up to track remote branch <span class="hljs-string">&#x27;util&#x27;</span> from <span class="hljs-string">&#x27;origin&#x27;</span>.<br>Switched to a new branch <span class="hljs-string">&#x27;util&#x27;</span><br><br>$ make qemu<br>···<br>xv6 kernel is booting<br><br>hart 2 starting<br>hart 1 starting<br>init: starting sh<br>$ ls<br>.              1 1 1024<br>..             1 1 1024<br>README         2 2 2059<br>xargstest.sh   2 3 93<br>cat            2 4 24256<br><span class="hljs-built_in">echo</span>           2 5 23080<br>(...other files)<br><br></code></pre></td></tr></table></figure><p>退出 <code>QEMU</code> 快捷键是 <code>Ctrl-a + x</code></p><p>好了，我们现在可以动手做实验了。</p><h2 id="如何在-QEMU-中使用-gdb"><a href="#如何在-QEMU-中使用-gdb" class="headerlink" title="如何在 QEMU 中使用 gdb"></a>如何在 <code>QEMU</code> 中使用 <code>gdb</code></h2><ol><li><p>首先用 <code>tmux</code> 开两个终端窗口。</p></li><li><p>第一个窗口键入<code>make qemu-gdb</code>.</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ make qemu-gdb<br>*** Now run <span class="hljs-string">&#x27;gdb&#x27;</span> <span class="hljs-keyword">in</span> another window. qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 3 -nographic -drive file=fs.img,<span class="hljs-keyword">if</span>=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0 -S -gdb tcp::26000<br></code></pre></td></tr></table></figure></li><li><p>在第二个窗口中:<br>3.1. 修改自己 <code>home</code> 目录下的 <code>.gdbinit</code> 文件，允许 <code>gdb</code> 在<code>xv6-labs-2020</code>这个目录启动的时候，加载该文件夹下的 <code>.gdbinit</code> 文件。 </p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;add-auto-load-safe-path <span class="hljs-subst">$(pwd)</span>/.gdbinit &quot;</span> &gt;&gt; ~/.gdbinit<br></code></pre></td></tr></table></figure><p> 3.2. 启动 <code>gdb-multiarch</code></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gdb-multiarch      <br>GNU gdb (Ubuntu 9.2-0ubuntu1~20.04) 9.2<br>Copyright (C) 2020 Free Software Foundation, Inc.<br>License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.ht<br>ml&gt;<br>This is free software: you are free to change and redistribute it.<br>There is NO WARRANTY, to the extent permitted by law.<br>Type <span class="hljs-string">&quot;show copying&quot;</span> and <span class="hljs-string">&quot;show warranty&quot;</span> <span class="hljs-keyword">for</span> details.<br>This GDB was configured as <span class="hljs-string">&quot;x86_64-linux-gnu&quot;</span>.<br>Type <span class="hljs-string">&quot;show configuration&quot;</span> <span class="hljs-keyword">for</span> configuration details.<br>For bug reporting instructions, please see:<br>&lt;http://www.gnu.org/software/gdb/bugs/&gt;.<br>Find the GDB manual and other documentation resources online at:<br>    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.<br><br>For <span class="hljs-built_in">help</span>, <span class="hljs-built_in">type</span> <span class="hljs-string">&quot;help&quot;</span>.<br>Type <span class="hljs-string">&quot;apropos word&quot;</span> to search <span class="hljs-keyword">for</span> commands related to <span class="hljs-string">&quot;word&quot;</span>.<br>The target architecture is assumed to be riscv:rv64<br>warning: No executable has been specified and target does not support<br>determining executable automatically.  Try using the <span class="hljs-string">&quot;file&quot;</span> <span class="hljs-built_in">command</span>.<br>0x0000000000001000 <span class="hljs-keyword">in</span> ?? ()<br>(gdb)<br></code></pre></td></tr></table></figure><p>3.3  <strong>给代码打断点</strong>  </p><ul><li><code>file user/_ls</code></li><li><code>b main</code></li><li><code>c</code></li><li>之后就是正常的<code>GDB</code>  使用流程了</li></ul><p> <strong>第二个窗口：</strong></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) file user/_ls<br>Reading symbols from user/_ls...<br>(gdb) b main<br>Breakpoint 1 at 0x27a: file user/ls.c, line 75.<br>(gdb) c<br>Continuing.<br>[Switching to Thread 1.3]<br><br>Thread 3 hit Breakpoint 1, main (argc=0, argv=0x6c &lt;fmtname+108&gt;)<br>    at user/ls.c:75<br>75      &#123;<br>(gdb)<br></code></pre></td></tr></table></figure><p> <strong>第一个窗口</strong></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">(......)<br>xv6 kernel is booting                                        <br>                                                                <br>hart 1 starting                                                  <br>hart 2 starting                                                  <br>init: starting sh                                                <br>$ ls<br>(等待 gdb 发送 <span class="hljs-built_in">continue</span> 信号)<br></code></pre></td></tr></table></figure><p> <img src="/img/6.S081/gdb.png" alt="图1：在QEMU中使用GDB"></p></li><li><p>之后我们就可以正常地通过 <code>GDB</code> 调试程序了~</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>MIT</tag>
      
      <tag>Open Course</tag>
      
      <tag>6.S081</tag>
      
      <tag>OS</tag>
      
      <tag>Lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Github Actions自动部署Hexo博客</title>
    <link href="/202106/Hexo-CI/"/>
    <url>/202106/Hexo-CI/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本文将介绍如何利用Github Actions功能自动部署博客。这样本地就不需要安装<code>Node.js</code>以及<code>Hexo</code>包，写完文档直接push到远程仓库，由Github Actions自动部署到博客网站上。由于本网站现阶段托管于<code>github.io</code>，因此我目前的需求是，推送博客文章的更改后，生成对应的静态网页，最后将静态网页内容自动推送到 <code>username.github.io</code> 这个仓库中。</p><h2 id="必要的准备"><a href="#必要的准备" class="headerlink" title="必要的准备"></a>必要的准备</h2><h3 id="测试常规Hexo部署流程"><a href="#测试常规Hexo部署流程" class="headerlink" title="测试常规Hexo部署流程"></a>测试常规Hexo部署流程</h3><p>参考<a href="https://hexo.io/zh-cn/docs/one-command-deployment">Hexo Doc</a>，</p><ol><li><p>安装 hexo-deployer-git</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure></li><li><p>修改Hexo项目的根目录中的<code>_config.yml</code>文件</p> <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span><br><span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br><span class="hljs-attr">repo:</span> <span class="hljs-string">&lt;git@github.com:username/username.github.io.git&gt;</span><br><span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">&lt;your-username?</span><br><span class="hljs-attr">email:</span> <span class="hljs-string">&lt;your-email&gt;</span><br></code></pre></td></tr></table></figure><p> 使用<code>hexo clean &amp;&amp; hexo g -d</code> 命令测试常规Hexo部署流程是否正常。</p></li></ol><h3 id="创建两个仓库"><a href="#创建两个仓库" class="headerlink" title="创建两个仓库"></a>创建两个仓库</h3><p><a href="https://hexo.io/zh-cn/docs/one-command-deploymen">Hexo部署文档</a>中有过说明，最好将Hexo项目目录与静态博客网页分别使用两个Git仓库管理，因此我们准备两个仓库。</p><ol><li>创建<code>my-blog</code>仓库存放Hexo项目目录</li><li>创建<code>username.github.io</code>仓库用来存放静态博客页面</li></ol><h3 id="配置密钥"><a href="#配置密钥" class="headerlink" title="配置密钥"></a>配置密钥</h3><ol><li><p>生成一个RSA密钥专供GitHub Actions部署Hexo网页使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh-keygen -f github-deploy-key<br></code></pre></td></tr></table></figure><p>当前目录下会有<code>github-deploy-key</code>（私钥）和<code>github-deploy-key.pub</code>（公钥）两个文件。</p></li><li><p>配置部署密钥<br> 2.1 复制公钥，设置为<code>username.github.io</code>仓库的部署密钥（<code>Settings -&gt; Deploy keys -&gt; Add deploy key</code>）</p><ul><li>Title 填写 <code>HEXO_DEPLOY_PUB</code></li><li>Key 填写复制的公钥</li><li>勾选<code>Allow write access</code>选项</li></ul><p> 2.2 复制私钥，设置为<code>my-blog</code>项目的密文（<code>Settings -&gt; Secrets -&gt; Add a new secret</code>）</p><ul><li>Name填写<code>HEXO_DEPLOY_PRI</code></li><li>Value填写复制的私钥</li></ul></li></ol><h2 id="编写Workflow"><a href="#编写Workflow" class="headerlink" title="编写Workflow"></a>编写Workflow</h2><p>Github使用workflow定义Github Actions的执行的环境与命令，作用类似于Gitlab中的<code>.gitlab-ci.yml</code></p><ol><li><p>在Hexo项目根目录下新建文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ mkdir -p .github/workflows<br>$ touch .github/workflows/deploy.yml<br></code></pre></td></tr></table></figure></li><li><p>编辑<code>deploy.yml</code></p> <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">name:</span> <span class="hljs-string">Hexo-CI</span><br><br><span class="hljs-attr">on:</span><br>    <span class="hljs-attr">push:</span><br>        <span class="hljs-attr">branches:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">master</span><br><br><span class="hljs-attr">env:</span><br><span class="hljs-attr">GIT_USER:</span> <span class="hljs-string">your-github-username</span><br><span class="hljs-attr">GIT_EMAIL:</span> <span class="hljs-string">your-github-email</span><br><span class="hljs-attr">THEME_NAME:</span> <span class="hljs-string">hexo-theme-fluid</span><br><span class="hljs-attr">DEPLOY_REPO:</span> <span class="hljs-string">username/username.github.io</span><br><span class="hljs-attr">DEPLOY_BRANCH:</span> <span class="hljs-string">master</span><br><br><span class="hljs-attr">jobs:</span><br><span class="hljs-attr">build:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">Build</span> <span class="hljs-string">on</span> <span class="hljs-string">node</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">matrix.node_version</span> <span class="hljs-string">&#125;&#125;</span> <span class="hljs-string">and</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">matrix.os</span> <span class="hljs-string">&#125;&#125;</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">strategy:</span><br>    <span class="hljs-attr">matrix:</span><br>        <span class="hljs-attr">os:</span> [<span class="hljs-string">ubuntu-latest</span>]<br>        <span class="hljs-attr">node_version:</span> [<span class="hljs-number">14.</span><span class="hljs-string">x</span>]<br><br>    <span class="hljs-attr">steps:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span><br>        <span class="hljs-attr">with:</span><br>        <span class="hljs-attr">ref:</span> <span class="hljs-string">master</span><br><br><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span> <span class="hljs-string">deploy</span> <span class="hljs-string">repo</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span><br>        <span class="hljs-attr">with:</span><br>        <span class="hljs-attr">repository:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">env.DEPLOY_REPO</span> <span class="hljs-string">&#125;&#125;</span><br>        <span class="hljs-attr">ref:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">env.DEPLOY_BRANCH</span> <span class="hljs-string">&#125;&#125;</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">.deploy_git</span><br><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Use</span> <span class="hljs-string">Node.js</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">matrix.node_version</span> <span class="hljs-string">&#125;&#125;</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v1</span><br>        <span class="hljs-attr">with:</span><br>        <span class="hljs-attr">node-version:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">matrix.node_version</span> <span class="hljs-string">&#125;&#125;</span><br><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Configuration</span> <span class="hljs-string">environment</span><br>        <span class="hljs-attr">env:</span><br>        <span class="hljs-attr">HEXO_DEPLOY_PRI:</span> <span class="hljs-string">$&#123;&#123;secrets.HEXO_DEPLOY_PRI&#125;&#125;</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">        sudo timedatectl set-timezone &quot;Asia/Shanghai&quot;</span><br><span class="hljs-string">        mkdir -p ~/.ssh/</span><br><span class="hljs-string">        echo &quot;$HEXO_DEPLOY_PRI&quot; &gt; ~/.ssh/id_rsa</span><br><span class="hljs-string">        chmod 600 ~/.ssh/id_rsa</span><br><span class="hljs-string">        ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span><br><span class="hljs-string">        git config --global user.name $GIT_USER</span><br><span class="hljs-string">        git config --global user.email $GIT_EMAIL</span><br><span class="hljs-string"></span>        <br><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">dependencies</span> <span class="hljs-string">and</span> <span class="hljs-string">theme</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">        npm install</span><br><span class="hljs-string">        npm install --save $&#123;&#123; env.THEME_NAME &#125;&#125;</span><br><span class="hljs-string"></span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">hexo</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br>        <span class="hljs-string">npm</span> <span class="hljs-string">run</span> <span class="hljs-string">deploy</span><br></code></pre></td></tr></table></figure></li><li><p>整理Hexo目录，推送更改到<code>my-blog</code>仓库<br><code>.gitignore</code>中应该包含对 <code>public/</code>, <code>.deploy_git/</code> 等由于Hexo生成静态网页的文件夹的排除</p></li><li><p>查看部署结果<br>查看<code>my-blog</code>仓库中Actions，可以看到本次推送触发Actions的执行结果。<br><img src="/img/hexo-ci/action-result.png"></p></li></ol><p><strong>模板参数说明</strong></p><ul><li><code>name</code> 为此 Action 的名字</li><li><code>on</code> 触发条件，目前含义为，当master分支收到推送后，触发Actions</li><li><code>env</code> 为一些环境变量，默认变量参考<a href="https://docs.github.com/cn/actions/reference/environment-variables">环境变量 on Github Docs</a></li><li><code>env.GIT_USER</code> 为 Hexo 编译后使用此 git 用户部署到仓库</li><li><code>env.GIT_EMAIL</code> 为 Hexo 编译后使用此 git 邮箱部署到仓库</li><li><code>env.THEME_NAME</code> 为您的 Hexo 所使用的主题的仓库，这里为 hexo-theme-fluid</li><li><code>env.DEPLOY_REPO</code> 为 Hexo 编译后要部署的仓库，写托管静态网页的仓库</li><li><code>env.DEPLOY_BRANCH</code> 为 Hexo 编译后要部署到的分支，如果是非master分支，参考<a href="https://hexo.io/zh-cn/docs/one-command-deployment#Git">Hexo Doc</a> 和<code>Github</code>仓库中<code>settings-&gt;pages-&gt;branch</code>处进行更改</li><li><code>jobs</code> 为此 Action 下的任务列表，具体语法参考<a href="https://docs.github.com/cn/actions/reference/workflow-syntax-for-github-actions">Job Vars on Github Docs</a></li><li><code>jobs.&#123;job&#125;.name</code> 任务名称</li><li><code>jobs.&#123;job&#125;.runs-on</code> 任务所需容器，可选值：ubuntu-latest、windows-latest、macos-latest。</li><li><code>jobs.&#123;job&#125;.steps.$.name</code> 步骤名，编译时会会以 LOG 形式输出。</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://sanonz.github.io/2020/deploy-a-hexo-blog-from-github-actions/">利用 Github Actions 自动部署 Hexo 博客</a></li><li><a href="https://printempw.github.io/use-github-actions-to-deploy-hexo-blog/">使用 GitHub Actions 自动部署 Hexo 博客</a></li><li><a href="https://docs.github.com/cn/actions/reference/workflow-syntax-for-github-actions">Github Actions Reference</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>CI</tag>
      
      <tag>Github</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
